<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANTLER MS1</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono&display=swap');
    </style>
    <style>
        :root {
            --space-base: 15px;
            --space-sm: 10px;
            --space-lg: 20px;
            --grey-medium: #666666;
            --grey-light: #cccccc;
        }

        html {
            font-size: 10px;
        }
        body {
            margin: 0;
            background-color: black;
            color: white;
            font-family: "Space Mono", sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            overflow-x: auto;
            font-size: 12px;
            letter-spacing: .1em;
        }
        body.dragging {
            cursor: ns-resize; /* Cursor during knob drag */
        }

        h1 {
            font-size: 15px;
            margin-top: 0;
            margin-bottom: 0;
            color: var(--grey-light);
            display: inline-block;
        }

        .info-text {
            color: var(--grey-medium);
            text-transform: uppercase;
            margin: 0;
        }

        .synth-panel {
            padding: 20px;
            display: grid;
            /* 4 Column Grid Layout */
            grid-template-columns: repeat(4, auto);
            gap: 20px 20px;
             min-width: 800px; /* Minimum width for the panel */
             width: max-content; /* Adjust width based on content */
        }

        .module {
            padding: var(--space-sm);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Spacing between elements inside a module */
            min-width: 100px;
            background-color: #151515;
            border-radius: 5px;
        }

        .module-title {
            padding: var(--space-base);
            margin-bottom: var(--space-sm);
            color: var(--grey-medium);
            width: 100%;
            padding-bottom: 5px;
            text-align: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px; /* Reduced gap to make space for value display */
            width: 100%; /* Ensure control groups take width for alignment */
            height: 70px; /* Increased min-height */
            justify-content: flex-start; /* Align items to the top */
            position: relative; /* Needed for absolute positioning of value display if chosen */
        }

         .control-group-horizontal {
             display: flex;
             flex-direction: row;
             align-items: baseline;
             justify-content: space-around;
             gap: var(--space-sm);
             width: 100%;
         }

        .bottom-control-group {
            margin-top: auto;
        }

        label {

            text-transform: uppercase;
            color: #bbb;
            line-height: 1rem;
             /* Make label height predictable */
             height: 1rem;
             margin-bottom: 2px;
        }

        .octave-label {
            height: auto; /* Override fixed height for waveform labels */
        }

        .waveform-label {
            font-size: 16px;
            height: auto; /* Override fixed height for waveform labels */
        }


        .knob {
            width: 40px;
            height: 40px;
            background-color: #282828;
            border: 1px solid #555;
            border-radius: 50%;
            position: relative;
            cursor: ns-resize; /* Vertical drag cursor */
            outline: none; /* Remove default focus outline */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            margin-bottom: 2px; /* Space between knob and value display */
        }

        .knob:before { /* The indicator line on the knob */
            content: '';
            position: absolute;
            width: 2px;
            height: 12px;
            background-color: #eee;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 50% 15px; /* Rotation origin */
        }

        .knob:focus { /* Highlight when focused */
            box-shadow: 0 0 0 2px white;
        }

        /* --- Value Display --- */
        .knob-value-display {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8em;
            background: black;
            border-radius: 2.5px;
            min-width: 30px;
            text-align: center;
            display: none; /* Hidden by default */
            position: absolute; /* Position relative to control-group */
            bottom: -0.8em;
            left: 50%;        /* Center horizontally */
            transform: translateX(-50%); /* Fine-tune centering */
            z-index: 10;      /* Ensure it's above other elements if needed */
        }

        /* Show display when knob is focused OR when dragging */
        .control-group:has(.knob:focus) .knob-value-display,
        .control-group.interacting .knob-value-display {
             display: inline-block;
        }
        /* Hide display for knobs with steps even when focused */
         .control-group:has(.knob[data-steps]:focus) .knob-value-display {
             display: none;
         }
         /* Hide display for knobs with steps even when interacting */
         .control-group.interacting:has(.knob[data-steps]) .knob-value-display {
              display: none;
         }

        /* --- Horizontal Switch --- */
        .switch {
             width: 50px;
             height: 30px;
             cursor: pointer;
             position: relative;
             border-radius: 3px;
             overflow: hidden;
             outline: none; /* Remove default focus outline */
        }

        .switch:before {
            content:'';
            height: 4px;
            background: black;
            display: inline-block;
            left: 0;
            right: 0;
            top: 13px;
            position: absolute;
            border-bottom: 1px solid #333333
        }


        .switch-handle {
            position: absolute;
            top: 2px;      /* Vertical positioning */
            bottom: 2px;   /* Vertical positioning */
            width: 5px;   /* Handle width */
            background-color: #eeeeee;
            border: 1px solid #222;
            border-radius: 2px;
            transition: left 0.1s ease-in-out; /* Animate left property */
        }

        /* Removed CSS handle positioning - now done in JS */
        /*
        .switch[data-state="up"] .switch-handle {
            left: 40px;
        }
        .switch[data-state="down"] .switch-handle {
            left: 2px;
        }
        */

        .switch:focus {
            box-shadow: 0 0 0 2px white;
         }

        /* --- Specific Module Layout (4 columns) --- */
        #header { grid-column: 1 / span 4; grid-row: 3; }
        
        #lfo-module { grid-column: 1; grid-row: 1; }
        #mixer-module { grid-column: 1; grid-row: 2; }

        #vco1-module { grid-column: 2; grid-row: 1; }
        #vco2-module { grid-column: 2; grid-row: 2; }

        #vcf-module { grid-column: 3; grid-row: 1; }
        #vca-module { grid-column: 3; grid-row: 2; }

        #system-module { grid-column: 4; grid-row: 1 / span 2; }

        #header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
        }

        /* Adjust VCF/VCA layout */
        #vcf-module, #vca-module {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Adjust gap as needed */
            align-items: center; /* Center align items */
            justify-content: start; /* Align content to the top */
        }
         .adsr-group {
             display: grid;
             grid-template-columns: repeat(4, 1fr); /* 4 equal columns */
             width: 100%;
             gap: 5px var(--space-sm); /* Row and column gap */
         }

         /* VCF Specific */
        #vcf-filter-controls {
            display: flex; /* Use flexbox for horizontal alignment */
            justify-content: space-around; /* Space out controls */
            width: 100%;
            gap: var(--space-sm); /* Add gap between filter controls */
            align-items: flex-start; /* Align groups to top */
        }
        #vcf-mod-controls {
            display: flex;
            justify-content: space-around;
             width: 100%;
             gap: 15px; /* Gap between LFO/ADSR mod knobs */
            align-items: flex-start;
        }

        /* VCA Specific */
        #vca-mod-controls {
             display: flex;
             justify-content: center; /* Center the single LFO Level knob */
             width: 100%;
             margin-top: var(--space-sm); /* Add space above VCA Mod controls */
             align-items: flex-start;
        }

        /* System Module Specific */
        #system-module {
            justify-content: start; /* Align controls to the top */
            gap: 18px; /* Adjust vertical gap between controls */
        }
        /* Make system module title consistent */
        #system-module .module-title {
             margin-bottom: 15px; /* More space after system title */
        }

    </style>
</head>
<body>

<div class="synth-panel" id="synth-panel">
    <div id="header">
        <h1>ANTLER MS1</h1>
        <p class="info-text">AWSEDFTGYHUJK | 1-0 | Arrows (+Shift)</p>
    </div>
    <!-- LFO -->
    <div class="module" id="lfo-module">
        <div class="module-title">LFO</div>
        <div class="control-group">
            <label for="lfo-speed">Speed</label>
            <div class="knob" id="lfo-speed" data-param="lfo.frequency.value" data-min="0.1" data-max="30" data-value="5" tabindex="0"></div>
            <span class="knob-value-display" id="lfo-speed-value"></span>
        </div>
        <div class="control-group">
            <label for="lfo-waveshape">
                <span class="waveform-label" id="lfo-shape-indicator">∿</span>
            </label>
            <div class="knob" id="lfo-waveshape" data-param="lfo.type" data-steps="sine,triangle,square,sawtooth,random" data-value="0" tabindex="0"></div>
            <!-- No value display for stepped knob -->
        </div>
    </div>

     <!-- Mixer -->
    <div class="module" id="mixer-module">
        <div class="module-title">MIXER</div>
        <div class="control-group">
            <label for="vco1-level">VCO 1</label>
            <div class="knob" id="vco1-level" data-param="vco1Gain.gain.value" data-min="0" data-max="1" data-value="0.7" tabindex="0"></div>
            <span class="knob-value-display" id="vco1-level-value"></span>
        </div>
        <div class="control-group">
            <label for="vco2-level">VCO 2</label>
            <div class="knob" id="vco2-level" data-param="vco2Gain.gain.value" data-min="0" data-max="1" data-value="0.7" tabindex="0"></div>
            <span class="knob-value-display" id="vco2-level-value"></span>
        </div>
        <div class="control-group">
            <label for="noise-level">Noise</label>
            <div class="knob" id="noise-level" data-param="noiseGain.gain.value" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
            <span class="knob-value-display" id="noise-level-value"></span>
        </div>
    </div>

    <!-- VCO 1 -->
    <div class="module" id="vco1-module">
        <div class="module-title">VCO 1</div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="vco1-octave">
                    <span class="octave-label" id="vco1-octave-indicator">8'</span>
                </label>
                <div class="knob" id="vco1-octave" data-param="vco1.octave" data-steps="32,16,8,4,2" data-value="2" tabindex="0"></div>
                 <!-- No value display for stepped knob -->
            </div>
            <div class="control-group">
                <label for="vco1-waveshape">
                    <span class="waveform-label" id="vco1-shape-indicator">⩘</span>
                </label>
                <div class="knob" id="vco1-waveshape" data-param="vco1.type" data-steps="triangle,sawtooth,square,sine" data-value="1" tabindex="0"></div>
                 <!-- No value display for stepped knob -->
            </div>
        </div>
        <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco1-lfo-level">LFO</label>
                <div class="knob" id="vco1-lfo-level" data-param="vco1LfoGain.gain.value" data-min="0" data-max="500" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vco1-lfo-level-value"></span>
            </div>
        </div>
    </div>

    <!-- VCO 2 -->
    <div class="module" id="vco2-module">
        <div class="module-title">VCO 2</div>
         <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco2-octave">
                    <span class="octave-label" id="vco2-octave-indicator">8'</span>
                </label>
                <div class="knob" id="vco2-octave" data-param="vco2.octave" data-steps="32,16,8,4,2" data-value="2" tabindex="0"></div>
                 <!-- No value display for stepped knob -->
            </div>
            <div class="control-group">
                <label for="vco2-waveshape">
                    <span class="waveform-label" id="vco2-shape-indicator">⩘</span>
                </label>
                <div class="knob" id="vco2-waveshape" data-param="vco2.type" data-steps="triangle,sawtooth,square,sine" data-value="1" tabindex="0"></div>
                 <!-- No value display for stepped knob -->
            </div>
         </div>
         <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco2-lfo-level">LFO</label>
                <div class="knob" id="vco2-lfo-level" data-param="vco2LfoGain.gain.value" data-min="0" data-max="500" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vco2-lfo-level-value"></span>
            </div>
            <div class="control-group">
                <label for="vco2-detune">Detune</label>
                <div class="knob" id="vco2-detune" data-param="vco2.detune.value" data-min="-100" data-max="100" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vco2-detune-value"></span>
            </div>
         </div>
    </div>

    <!-- VCF -->
    <div class="module" id="vcf-module">
        <div class="module-title">VCF</div>
        <div id="vcf-filter-controls"> <!-- Horizontal layout -->
            <div class="control-group">
                <label for="vcf-cutoff">Cutoff</label>
                <div class="knob" id="vcf-cutoff" data-param="filter.frequency.value" data-min="20" data-max="20000" data-value="20000" data-curve="log" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-cutoff-value"></span>
            </div>
             <div class="control-group">
                <label for="vcf-res">Res</label>
                <div class="knob" id="vcf-res" data-param="filter.Q.value" data-min="0" data-max="30" data-value="1" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-res-value"></span>
            </div>
             <div class="control-group"> <!-- Container for switch -->
                 <label class="sr-only">
                    <label id="vcf-type-label">LO HI</label>
                 </label>
                 <div class="switch" id="vcf-type" data-state="down" data-param="filter.type" data-values="highpass,lowpass" tabindex="0">
                     <div class="switch-handle"></div>
                 </div>
             </div>
        </div>
        <div class="adsr-group">
            <div class="control-group">
                <label for="vcf-attack">A</label>
                <div class="knob" id="vcf-attack" data-param="vcfEnv.attack" data-min="0.005" data-max="2" data-value="0.01" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-attack-value"></span>
            </div>
            <div class="control-group">
                <label for="vcf-decay">D</label>
                <div class="knob" id="vcf-decay" data-param="vcfEnv.decay" data-min="0.005" data-max="2" data-value="0.01" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-decay-value"></span>
            </div>
            <div class="control-group">
                <label for="vcf-sustain">S</label>
                <div class="knob" id="vcf-sustain" data-param="vcfEnv.sustain" data-min="0" data-max="1" data-value="2" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-sustain-value"></span>
            </div>
            <div class="control-group">
                <label for="vcf-release">R</label>
                <div class="knob" id="vcf-release" data-param="vcfEnv.release" data-min="0.005" data-max="5" data-value="0.01" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-release-value"></span>
            </div>
        </div>
         <div id="vcf-mod-controls">
            <div class="control-group">
                <label for="vcf-lfo-level">LFO</label>
                <div class="knob" id="vcf-lfo-level" data-param="vcfLfoGain.gain.value" data-min="0" data-max="5000" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-lfo-level-value"></span>
            </div>
            <div class="control-group">
                <label for="vcf-adsr-level">ADSR</label>
                <div class="knob" id="vcf-adsr-level" data-param="vcfEnvGain.gain.value" data-min="0" data-max="8000" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vcf-adsr-level-value"></span>
            </div>
        </div>
    </div>

    <!-- VCA -->
    <div class="module" id="vca-module">
        <div class="module-title">VCA</div>
         <div class="adsr-group">
            <div class="control-group">
                <label for="vca-attack">A</label>
                <div class="knob" id="vca-attack" data-param="vcaEnv.attack" data-min="0.005" data-max="2" data-value="0.01" tabindex="0"></div>
                <span class="knob-value-display" id="vca-attack-value"></span>
            </div>
            <div class="control-group">
                <label for="vca-decay">D</label>
                <div class="knob" id="vca-decay" data-param="vcaEnv.decay" data-min="0.005" data-max="2" data-value="0.01" tabindex="0"></div>
                <span class="knob-value-display" id="vca-decay-value"></span>
            </div>
            <div class="control-group">
                <label for="vca-sustain">S</label>
                <div class="knob" id="vca-sustain" data-param="vcaEnv.sustain" data-min="0" data-max="1" data-value="2" tabindex="0"></div>
                <span class="knob-value-display" id="vca-sustain-value"></span>
            </div>
            <div class="control-group">
                <label for="vca-release">R</label>
                <div class="knob" id="vca-release" data-param="vcaEnv.release" data-min="0.005" data-max="5" data-value="0.01" tabindex="0"></div>
                 <span class="knob-value-display" id="vca-release-value"></span>
           </div>
        </div>
         <div id="vca-mod-controls">
             <div class="control-group">
                <label for="vca-lfo-level">LFO</label>
                <div class="knob" id="vca-lfo-level" data-param="vcaLfoGain.gain.value" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="vca-lfo-level-value"></span>
            </div>
         </div>
    </div>

     <!-- System Controls -->
    <div class="module" id="system-module">
         <div class="module-title">SYSTEM & FX</div>
        <div class="control-group">
            <label for="portamento">Portamento</label>
            <div class="knob" id="portamento" data-param="portamentoTime" data-min="0" data-max="0.5" data-value="0" tabindex="0"></div>
            <span class="knob-value-display" id="portamento-value"></span>
        </div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="delay-time">Dly Time</label>
                <div class="knob" id="delay-time" data-param="delayTime.delayTime.value" data-min="0.05" data-max=".75" data-value="0.15" data-curve="log" tabindex="0"></div>
                <span class="knob-value-display" id="delay-time-value"></span>
            </div>
            <div class="control-group">
                <label for="delay-feedback">Dly Fdbk</label>
                <div class="knob" id="delay-feedback" data-param="delayFeedbackGain.gain.value" data-min="0" data-max="1" data-value=".5" tabindex="0"></div>
                <span class="knob-value-display" id="delay-feedback-value"></span>
            </div>
        </div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="delay-level">Dly Level</label>
                <div class="knob" id="delay-level" data-param="delayLevel" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="delay-level-value"></span>
            </div>
            <div class="control-group">
                <label for="reverb-level">Reverb</label>
                <div class="knob" id="reverb-level" data-param="reverbLevel" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="reverb-level-value"></span>
            </div>
        </div>
        <div class="control-group-horizontal">
             <div class="control-group">
                <label for="distortion-amount">Drive</label>
                <div class="knob" id="distortion-amount" data-param="distortionAmount" data-min="0" data-max="100" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="distortion-amount-value"></span>
            </div>
        </div>
        <div class="control-group-horizontal bottom-control-group">
            <div class="control-group">
                <label for="tune">Tune</label>
                <div class="knob" id="tune" data-param="masterTune" data-min="-100" data-max="100" data-value="0" tabindex="0"></div>
                <span class="knob-value-display" id="tune-value"></span>
            </div>
            <div class="control-group">
                <label for="volume">Volume</label>
                <div class="knob" id="volume" data-param="masterGain.gain.value" data-min="0" data-max="1" data-value="0.5" tabindex="0"></div>
                <span class="knob-value-display" id="volume-value"></span>
            </div>
        </div>
    </div>

</div>
<script>
    // ----- SYNTH PANEL ELEMENTS -----
    const synthPanel = document.getElementById('synth-panel');
    let knobs;
    let switches;


    // ----- AUDIO CONTEXT & NODES -----
    let audioContext;
    let masterGain;
    let vco1, vco2; // Persistent Oscillators
    let vco1Gain, vco2Gain;
    let noiseSource, noiseGain; // Persistent Noise Source
    let filter; // Main VCF
    let vcaEnvelopeGain; // Master VCA controlled ONLY by envelope

    let lfo, vco1LfoGain, vco2LfoGain, vcfLfoGain, vcaLfoGain;
    let vcfEnvGain;

    // --- LFO NODES ---
    let lfoOscGain;
    let lfoRandomNode;
    let lfoRandomGain;
    let lfoRandomFrequencyParam;

    // --- VCA LFO Modulation ---
    let vcaLfoModGain;
    let lfoVcaBaseGain;

    // --- FX Nodes ---
    let distortion;
    let delay, delayFeedbackGain, delayWetGain;
    let reverb, reverbWetGain, reverbLPF; // <<< ADDED reverbLPF
    let effectsInput; // Point where signal enters FX chain (after main VCA/Filter)


    let isAudioInitialized = false;
    let isAudioResumed = false;

    // -----DEFAULT SYNTH PARAMETERS -----
    const params = {
        masterTune: 0,
        portamentoTime: 0,
        vco1: { octave: 2, type: 'sawtooth' },
        vco2: { octave: 2, type: 'sawtooth', detune: { value: 0 } },
        vcfEnv: { attack: 0.01, decay: 0.01, sustain: 1.0, release: 0.01 },
        vcaEnv: { attack: 0.01, decay: 0.01, sustain: 1.0, release: 0.01 },
        lfo: { frequency: { value: 5 }, type: 'sine' },
        vco1Gain: { gain: { value: 0.7 } },
        vco2Gain: { gain: { value: 0.7 } },
        noiseGain: { gain: { value: 0 } },
        filter: { frequency: { value: 20000 }, Q: { value: 1 }, type: 'lowpass' },
        vco1LfoGain: { gain: { value: 0 } },
        vco2LfoGain: { gain: { value: 0 } },
        vcfLfoGain: { gain: { value: 0 } },
        vcaLfoGain: { gain: { value: 0 } },
        vcfEnvGain: { gain: { value: 0 } },
        // --- FX Params ---
        distortionAmount: 0,
        delayTime: { delayTime: { value: 0.15 } },
        delayFeedbackGain: { gain: { value: 0.5 } },
        delayLevel: 0,
        reverbLevel: 0,
        // Internal nodes for FX chain control (may not be needed in params directly)
        // delayWetGain: { gain: { value: 0 } }, // Controlled by delayLevel
        // reverbWetGain: { gain: { value: 0 } }, // Controlled by reverbLevel (with boost)
        masterGain: { gain: { value: 0.5 } }
    };

    // ----- CONSTANTS & MAPPINGS -----
    const octaveSteps = [32, 16, 8, 4, 2];
    const octaveMultipliers = [1/8, 1/4, 1/2, 1, 2];
    const vcoWaveforms = ['triangle', 'sawtooth', 'square', 'sine'];
    const vcoShapeIndicators = ['⋀', '⩘', '⨅', '∿'];
    const lfoWaveforms = ['sine','triangle','square','sawtooth','random'];
    const lfoShapeIndicators = ['∿', '⋀', '⨅', '⩘', '﹖'];
    const FILTER_TYPES = ['highpass', 'lowpass'];

    // ----- MONO SYNTH STATE -----
    let pressedKeys = {};
    let currentNote = null;
    let currentFrequency = 0;
    const MIDI_C4 = 69;
    const keyToNoteMap = { 'KeyA': 60, 'KeyW': 61, 'KeyS': 62, 'KeyE': 63, 'KeyD': 64, 'KeyF': 65, 'KeyT': 66, 'KeyG': 67, 'KeyY': 68, 'KeyH': 69, 'KeyU': 70, 'KeyJ': 71, 'KeyK': 72 };

    // ----- UTILITY FUNCTIONS -----
    // (midiToFreq, calculateVcoFrequency, makeDistortionCurve, formatKnobValue, updateKnobValueDisplay - unchanged)
    function midiToFreq(midiNote) { return 440 * Math.pow(2, (midiNote - MIDI_C4) / 12); }
    function calculateVcoFrequency(baseFreq, vcoParams) { let octaveIndex = vcoParams.octave; if (typeof octaveIndex !== 'number' || isNaN(octaveIndex) || octaveIndex < 0 || octaveIndex >= octaveMultipliers.length) { console.warn(`Invalid octaveIndex (${octaveIndex}), defaulting to 2`); octaveIndex = 2; } const freq = baseFreq * octaveMultipliers[octaveIndex]; const safeFreq = Math.max(20, Math.min((audioContext?.sampleRate || 44100) / 2, freq)); if (!isFinite(safeFreq)) { console.error("FATAL: Calculated VCO frequency non-finite!", freq, baseFreq, octaveIndex); return 440; } return safeFreq; }
    function makeDistortionCurve(amount) {
    if (!audioContext) return null;
    const k = typeof amount === 'number' ? Math.max(0, amount) : 0; // Ensure k is non-negative
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);

    // --- INCREASED STEEPNESS ---
    // Original divisor was 50 in the tanh calculation: (k / 50 + 1)
    // Try a smaller divisor. Lower value = more intense faster.
    const divisor = 10; // <<< TUNE THIS VALUE (e.g., 10, 15, 20)
    const steepness = 1 + (k / divisor);
    // ---

    let x;
    for (let i = 0; i < n_samples; ++i) {
        x = i * 2 / n_samples - 1; // Input signal sample (-1 to 1)

        // Original curve had (Math.PI/2) * Math.tanh(...)
        // Using just Math.tanh allows output to reach +/- 1 more easily potentially adding intensity
        curve[i] = Math.tanh(x * steepness);
    }
    return curve;
}
    function formatKnobValue(value, knobId) { if (typeof value !== 'number' || !isFinite(value)) { return '---'; } if (knobId && knobId.includes('cutoff')) { return value >= 1000 ? (value / 1000).toFixed(1) + 'k' : value.toFixed(0); } else if (knobId && (knobId.includes('attack') || knobId.includes('decay') || knobId.includes('release') || knobId.includes('time'))) { return value < 1 ? (value * 1000).toFixed(0) + 'ms' : value.toFixed(2) + 's'; } else if (knobId && (knobId.includes('tune') || knobId.includes('detune') || knobId.includes('lfo-level'))) { return value.toFixed(1); } else if (knobId && knobId.includes('res')) { return value.toFixed(1); } else { return value.toFixed(2); } }
    function updateKnobValueDisplay(knob, value) { if (knob && !knob.dataset.steps) { const displayId = knob.id + '-value'; const displayElement = document.getElementById(displayId); if (displayElement) { displayElement.textContent = formatKnobValue(value, knob.id); } } }


    // ----- AUDIO CONTEXT & INITIALIZATION -----
    // (ensureAudioContextResumed, rampUpMasterGain - unchanged)
    async function ensureAudioContextResumed() { if (!audioContext) { console.error("Context not initialized."); return false; } try { if (audioContext.state === 'running') { if (!isAudioResumed) { isAudioResumed = true; rampUpMasterGain(); } return true; } if (audioContext.state === 'suspended') { console.log("Context suspended. Resuming..."); await audioContext.resume(); if (audioContext.state === 'running') { console.log("Resumed."); isAudioResumed = true; rampUpMasterGain(); return true; } console.warn("Still not running after resume:", audioContext.state); isAudioResumed = false; return false; } if (audioContext.state === 'closed') { console.error("Context closed."); isAudioInitialized = false; isAudioResumed = false; return false; } console.warn("Unexpected state:", audioContext.state); isAudioResumed = false; return false; } catch (e) { console.error("Error resuming:", e); isAudioResumed = false; return false; } }
    function rampUpMasterGain() { if (!audioContext || !masterGain || audioContext.state !== 'running') return; const targetVolume = params.masterGain.gain.value; const currentVolume = masterGain.gain.value; if (Math.abs(currentVolume - targetVolume) < 0.01) return; const rampTime = 0.05; console.log(`Ramping master gain to ${targetVolume} over ${rampTime}s`); masterGain.gain.setValueAtTime(currentVolume, audioContext.currentTime); masterGain.gain.linearRampToValueAtTime(targetVolume, audioContext.currentTime + rampTime); }

    async function initAudio() {
        if (isAudioInitialized) return;
        console.log("Initializing AudioContext...");
        try {
            if (!window.AudioContext && !window.webkitAudioContext) throw new Error("Web Audio API not supported");
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (!audioContext) throw new Error("Failed to create AudioContext");
            if (!audioContext.audioWorklet) throw new Error("AudioWorklet not supported");

            console.log("Loading Random LFO AudioWorklet module...");
            try {
                // IMPORTANT: Ensure 'random-lfo-processor.js' exists at the correct path relative to your HTML file
                await audioContext.audioWorklet.addModule('random-lfo-processor.js');
                console.log("AudioWorklet module loaded successfully.");
            } catch (e) {
                 console.error("Failed to load AudioWorklet module 'random-lfo-processor.js'. Make sure the file exists and the path is correct.", e);
                 // Optionally provide a fallback or stop initialization
                 // For now, we'll throw to make the issue clear.
                 throw new Error(`Failed to load AudioWorklet module: ${e.message}`);
            }
            isAudioInitialized = true;
            console.log("Initial AudioContext State:", audioContext.state);

            // --- Create Core Synth Nodes (As before) ---
            masterGain = audioContext.createGain(); params.masterGain.node = masterGain;
            masterGain.gain.value = 0; // Start muted

            vco1 = audioContext.createOscillator(); params.vco1.node = vco1;
            vco2 = audioContext.createOscillator(); params.vco2.node = vco2;
            vco1Gain = audioContext.createGain(); params.vco1Gain.node = vco1Gain;
            vco2Gain = audioContext.createGain(); params.vco2Gain.node = vco2Gain;
            noiseGain = audioContext.createGain(); params.noiseGain.node = noiseGain;
            filter = audioContext.createBiquadFilter(); params.filter.node = filter;
            filter.frequency.value = params.filter.frequency.value; // Initialize
            vcaEnvelopeGain = audioContext.createGain(); vcaEnvelopeGain.gain.value = 0;
            vcaLfoModGain = audioContext.createGain(); vcaLfoModGain.gain.value = 0; // Modulated by VCA LFO
            lfoVcaBaseGain = audioContext.createConstantSource(); lfoVcaBaseGain.offset.value = 1.0; // Base for VCA LFO mod

            lfo = audioContext.createOscillator(); params.lfo.node = lfo;
            vco1LfoGain = audioContext.createGain(); params.vco1LfoGain.node = vco1LfoGain;
            vco2LfoGain = audioContext.createGain(); params.vco2LfoGain.node = vco2LfoGain;
            vcfLfoGain = audioContext.createGain(); params.vcfLfoGain.node = vcfLfoGain;
            vcaLfoGain = audioContext.createGain(); params.vcaLfoGain.node = vcaLfoGain;
            vcfEnvGain = audioContext.createGain(); params.vcfEnvGain.node = vcfEnvGain;

            lfoOscGain = audioContext.createGain(); // For switching LFO waveform sources
            lfoRandomGain = audioContext.createGain();
            lfoRandomNode = new AudioWorkletNode(audioContext, 'random-lfo-processor');
            lfoRandomFrequencyParam = lfoRandomNode.parameters.get('frequency');
            if (!lfoRandomFrequencyParam) console.warn("Could not get 'frequency' parameter from random LFO worklet.");

            // --- Create Noise Source (As before) ---
             const bufferSize = audioContext.sampleRate * 2;
             const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
             const output = noiseBuffer.getChannelData(0);
             for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
             noiseSource = audioContext.createBufferSource();
             noiseSource.buffer = noiseBuffer; noiseSource.loop = true;
             params.noiseSource = { node: noiseSource }; // Store if needed

            // --- Create FX Nodes (NEW and existing) ---
            effectsInput = audioContext.createGain();       // Explicit entry point for FX
            preDistMix = audioContext.createGain();         // Mixes Dry + Wet FX before distortion
            fxReturnMix = audioContext.createGain();        // Collects wet delay & reverb

            distortion = audioContext.createWaveShaper();   // Distortion effect

            delay = audioContext.createDelay(2.0);          // Max delay time 2s
            params.delayTime.node = delay;                  // Store node if needed by param system
            delayFeedbackGain = audioContext.createGain();
            params.delayFeedbackGain.node = delayFeedbackGain; // Store node if needed
            delayWetGain = audioContext.createGain();       // Controlled by delayLevel

            reverb = audioContext.createConvolver();        // Reverb effect
            reverbWetGain = audioContext.createGain();      // Controlled by reverbLevel
            reverbLPF = audioContext.createBiquadFilter();  // Filter for reverb output

            // --- Create Reverb Impulse (Mono - As before) ---
             const reverbTime = 2, reverbDecay = 4.0, sampleRate = audioContext.sampleRate;
             const length = sampleRate * reverbTime;
             const impulse = audioContext.createBuffer(1, length, sampleRate); // MONO
             const impulseData = impulse.getChannelData(0);
             for (let i = 0; i < length; i++) {
                  const envelope = Math.pow(1 - i / length, reverbDecay);
                  impulseData[i] = (Math.random() * 2 - 1) * envelope;
             }
             reverb.buffer = impulse;
             // --- End Reverb Impulse ---

             // --- Configure Reverb Filter ---
             reverbLPF.type = 'lowpass';
             reverbLPF.frequency.value = 1300; // Adjust as desired
             reverbLPF.Q.value = 1;
             // --- End Reverb Filter Config ---

            // --- Connect Audio Graph (SYNTH PART - Mostly As Before) ---
             // LFO Path Switching & Destinations
             lfo.connect(lfoOscGain); lfoRandomNode.connect(lfoRandomGain);
             lfoOscGain.connect(vco1LfoGain); lfoRandomGain.connect(vco1LfoGain); vco1LfoGain.connect(vco1.detune);
             lfoOscGain.connect(vco2LfoGain); lfoRandomGain.connect(vco2LfoGain); vco2LfoGain.connect(vco2.detune);
             lfoOscGain.connect(vcfLfoGain); lfoRandomGain.connect(vcfLfoGain); vcfLfoGain.connect(filter.frequency);
             lfoOscGain.connect(vcaLfoGain); lfoRandomGain.connect(vcaLfoGain); vcaLfoGain.connect(vcaLfoModGain.gain); // Modulates VCA LFO amount

             // VCF Envelope
             vcfEnvGain.connect(filter.frequency);

             // Oscillators & Noise -> Mixer -> Filter
             vco1.connect(vco1Gain); vco2.connect(vco2Gain); noiseSource.connect(noiseGain);
             vco1Gain.connect(filter); vco2Gain.connect(filter); noiseGain.connect(filter);

            // Filter -> VCA Envelope -> VCA LFO Mod -> EFFECTS INPUT (Connects synth output to FX chain)
             filter.connect(vcaEnvelopeGain);
             vcaEnvelopeGain.connect(vcaLfoModGain);
             lfoVcaBaseGain.connect(vcaLfoModGain.gain); // Constant source providing base gain for LFO modulation subtraction/addition
             vcaLfoModGain.connect(effectsInput); // <<< POINT WHERE SYNTH OUTPUT ENTERS FX CHAIN

             // --- Connect Audio Graph (FX PART - NEW ROUTING) ---

             // 1. Dry Path: FX Input -> Pre-Distortion Mix
             effectsInput.connect(preDistMix);

             // 2. Send to Delay: FX Input -> Delay Input
             effectsInput.connect(delay);

             // 3. Delay Chain: Feedback Loop
             delay.connect(delayFeedbackGain);
             delayFeedbackGain.connect(delay);

             // 4. Wet Delay Path:
             //    a) Delay Output -> Delay Wet Gain (controlled by knob)
             delay.connect(delayWetGain);
             //    b) Wet Delay -> FX Return Mix (to be mixed with dry)
             delayWetGain.connect(fxReturnMix);
             //    c) Wet Delay -> Reverb Input (Delay repeats feed reverb)
             delayWetGain.connect(reverb); // <<< DELAY FEEDS REVERB

             // 5. Send to Reverb (Direct): FX Input -> Reverb Input
             effectsInput.connect(reverb); // <<< MAIN SIGNAL FEEDS REVERB

             // 6. Reverb Chain:
             //    a) Reverb Output -> Reverb Wet Gain (controlled by knob)
             reverb.connect(reverbWetGain);
             //    b) Wet Reverb -> LPF
             reverbWetGain.connect(reverbLPF);
             //    c) Filtered Reverb -> FX Return Mix
             reverbLPF.connect(fxReturnMix);

             // 7. Combine Dry + Wet FX:
             //    a) FX Return (Wet Delay + Wet Reverb) -> Pre-Distortion Mix
             fxReturnMix.connect(preDistMix);

             // 8. Distortion Stage:
             //    a) Combined Signal -> Distortion Curve
             preDistMix.connect(distortion);

             // 9. Master Output:
             //    a) Distortion -> Master Gain (Volume)
             distortion.connect(masterGain);
             //    b) Master Gain -> Destination
             masterGain.connect(audioContext.destination);

             // --- End Audio Graph Connections ---

            // --- Start Persistent Oscillators & Sources ---
            lfo.start();
            lfoVcaBaseGain.start();
            vco1.start();
            vco2.start();
            noiseSource.start();
            lfoRandomNode.connect(audioContext.destination); // Need to connect worklet to trigger processing
            lfoRandomNode.disconnect(audioContext.destination); // Disconnect immediately, connection just starts it.

            // --- Initialize UI and Set Initial Audio Node Values ---
            updateAllKnobs(true); // This will set initial FX levels via updateParameter
            updateAllSwitches(true);

            // --- Final State Check & Master Gain Ramp ---
            if (audioContext.state === 'running') {
                isAudioResumed = true;
                rampUpMasterGain(); // Use existing ramp function
            }
            else {
                isAudioResumed = false;
                console.log("Audio graph initialized, context suspended.");
            }

        } catch (e) {
             console.error("Error initializing Web Audio API or Worklet:", e);
             isAudioInitialized = false; isAudioResumed = false;
             alert("Web Audio API/Worklet initialization failed: " + e.message + "\n\nPlease check console for details (e.g., missing 'random-lfo-processor.js').");
        }
    }

    // ----- ENVELOPE FUNCTIONS -----
    // (triggerEnvelope, releaseEnvelope, triggerEnvelopes, releaseEnvelopes - unchanged)
    function triggerEnvelope(envParams, targetParam, sustainValue, now, isVcf = false) { if (!audioContext || !targetParam || now === undefined || now <= 0) { return; } const { attack, decay } = envParams; const safeAttack = Math.max(0.001, attack); const safeDecay = Math.max(0.001, decay); targetParam.cancelScheduledValues(now); if (isVcf) { const knobBaseFreq = params.filter.frequency.value; const envModAmount = params.vcfEnvGain.gain.value; const baseFreq = Math.max(20, knobBaseFreq); const attackPeakFreq = baseFreq + envModAmount; const sustainLevelFreq = baseFreq + (sustainValue * envModAmount); const nyquist = audioContext.sampleRate / 2; const clampedBaseFreq = Math.min(nyquist, Math.max(20, baseFreq)); const validAttackPeakFreq = (typeof attackPeakFreq === 'number' && isFinite(attackPeakFreq)) ? attackPeakFreq : clampedBaseFreq; const clampedPeakFreq = Math.min(nyquist, Math.max(20, validAttackPeakFreq)); const clampedSustainFreq = Math.min(nyquist, Math.max(20, sustainLevelFreq)); let startValue = clampedBaseFreq; try { startValue = targetParam.value; } catch(e){} targetParam.setValueAtTime(startValue, now); if (!isFinite(startValue) || startValue < 0) { startValue = clampedBaseFreq; targetParam.setValueAtTime(startValue, now); } targetParam.linearRampToValueAtTime(clampedPeakFreq, now + safeAttack); targetParam.linearRampToValueAtTime(clampedSustainFreq, now + safeAttack + safeDecay); } else { const peakVal = 1.0; const sustainLevel = Math.max(0.0001, sustainValue); let startGain = 0.0001; try { const currentGain = targetParam.value; if (typeof currentGain === 'number' && isFinite(currentGain) && currentGain >= 0) { startGain = Math.max(0.00001, currentGain); } } catch (err) {} targetParam.setValueAtTime(startGain, now); targetParam.linearRampToValueAtTime(peakVal, now + safeAttack); targetParam.linearRampToValueAtTime(sustainLevel, now + safeAttack + safeDecay); } }
    function releaseEnvelope(envParams, targetParam, now, isVcf = false) { if (!audioContext || !targetParam) return; const { release } = envParams; const safeRelease = Math.max(0.001, release); const validNow = (now !== undefined && now > 0) ? now : audioContext.currentTime; targetParam.cancelScheduledValues(validNow); let releaseTargetValue; let currentValue = targetParam.value; try { if (typeof currentValue !== 'number' || !isFinite(currentValue)) { currentValue = isVcf ? params.filter.frequency.value : params.vcaEnv.sustain; } } catch (e) { currentValue = isVcf ? params.filter.frequency.value : params.vcaEnv.sustain; } if (isVcf) { releaseTargetValue = Math.min(audioContext.sampleRate / 2, Math.max(20, params.filter.frequency.value)); } else { releaseTargetValue = 0.00001; } targetParam.setValueAtTime(currentValue, validNow); targetParam.linearRampToValueAtTime(releaseTargetValue, validNow + safeRelease); }
    function triggerEnvelopes(now) { if (!filter || !vcaEnvelopeGain) return; triggerEnvelope(params.vcfEnv, filter.frequency, params.vcfEnv.sustain, now, true); triggerEnvelope(params.vcaEnv, vcaEnvelopeGain.gain, params.vcaEnv.sustain, now, false); }
    function releaseEnvelopes(now) { if (!filter || !vcaEnvelopeGain) return; releaseEnvelope(params.vcfEnv, filter.frequency, now, true); releaseEnvelope(params.vcaEnv, vcaEnvelopeGain.gain, now, false); }

    // ----- MONOPHONIC NOTE HANDLING -----
    // (noteOn, noteOff, noteToKeyCode - unchanged)
    function noteOn(note, freq) { if (!audioContext || audioContext.state !== 'running' || !vco1 || !vco2) { return; } const now = audioContext.currentTime; const portamento = params.portamentoTime > 0.005 ? params.portamentoTime : 0; const targetOsc1Freq = calculateVcoFrequency(freq, params.vco1); const targetOsc2Freq = calculateVcoFrequency(freq, params.vco2); const glideTime = portamento / 4; if (currentNote !== null) { currentFrequency = freq; currentNote = note; vco1.frequency.cancelScheduledValues(now); vco2.frequency.cancelScheduledValues(now); if (portamento > 0) { vco1.frequency.setTargetAtTime(targetOsc1Freq, now, glideTime); vco2.frequency.setTargetAtTime(targetOsc2Freq, now, glideTime); } else { vco1.frequency.setValueAtTime(targetOsc1Freq, now); vco2.frequency.setValueAtTime(targetOsc2Freq, now); } } else { currentFrequency = freq; currentNote = note; vco1.frequency.cancelScheduledValues(now); vco2.frequency.cancelScheduledValues(now); vco1.frequency.setValueAtTime(targetOsc1Freq, now); vco2.frequency.setValueAtTime(targetOsc2Freq, now); triggerEnvelopes(now); } }
    function noteOff(note) { if (!isAudioInitialized || !isAudioResumed || currentNote === null || !vco1 || !vco2) return; let highestRemainingNote = -1; let highestRemainingFreq = 0; for (const code in pressedKeys) { if (pressedKeys[code] && keyToNoteMap[code] && keyToNoteMap[code] !== note) { const remainingNote = keyToNoteMap[code]; if (remainingNote > highestRemainingNote) { highestRemainingNote = remainingNote; highestRemainingFreq = midiToFreq(remainingNote); } } } if (note === currentNote) { if (highestRemainingNote > -1) { const now = audioContext.currentTime; const portamento = params.portamentoTime > 0.005 ? params.portamentoTime : 0; const targetOsc1Freq = calculateVcoFrequency(highestRemainingFreq, params.vco1); const targetOsc2Freq = calculateVcoFrequency(highestRemainingFreq, params.vco2); const glideTime = portamento / 4; currentFrequency = highestRemainingFreq; currentNote = highestRemainingNote; vco1.frequency.cancelScheduledValues(now); vco2.frequency.cancelScheduledValues(now); if (portamento > 0) { vco1.frequency.setTargetAtTime(targetOsc1Freq, now, glideTime); vco2.frequency.setTargetAtTime(targetOsc2Freq, now, glideTime); } else { vco1.frequency.setValueAtTime(targetOsc1Freq, now); vco2.frequency.setValueAtTime(targetOsc2Freq, now); } } else { const now = audioContext.currentTime; releaseEnvelopes(now); currentNote = null; currentFrequency = 0; } } delete pressedKeys[noteToKeyCode(note)]; }
    function noteToKeyCode(note) { for (const code in keyToNoteMap) { if (keyToNoteMap[code] === note) { return code; } } return null; }

    // ----- UI UPDATE FUNCTIONS -----
    // (updateKnobVisual, updateSwitchVisual - unchanged)
    function updateKnobVisual(knob, valueForRotation, actualAudioValue) { knob.dataset.actualValue = typeof actualAudioValue === 'number' ? actualAudioValue.toFixed(5) : String(actualAudioValue); const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null; let percentage = Math.max(0, Math.min(1, valueForRotation)); if (steps) { const numSteps = steps.length; const stepIndex = numSteps > 1 ? Math.round(percentage * (numSteps - 1)) : 0; if (knob.id === 'lfo-waveshape') document.getElementById('lfo-shape-indicator').textContent = lfoShapeIndicators[stepIndex] || '?'; else if (knob.id === 'vco1-waveshape') document.getElementById('vco1-shape-indicator').textContent = vcoShapeIndicators[stepIndex] || '?'; else if (knob.id === 'vco2-waveshape') document.getElementById('vco2-shape-indicator').textContent = vcoShapeIndicators[stepIndex] || '?'; else if (knob.id === 'vco1-octave') document.getElementById('vco1-octave-indicator').textContent = octaveSteps[stepIndex] ? octaveSteps[stepIndex] + "'" : '?'; else if (knob.id === 'vco2-octave') document.getElementById('vco2-octave-indicator').textContent = octaveSteps[stepIndex] ? octaveSteps[stepIndex] + "'" : '?'; } else { updateKnobValueDisplay(knob, actualAudioValue); } const rotation = -135 + (percentage * 270); knob.style.transform = `rotate(${rotation}deg)`; }
    function updateSwitchVisual(sw) { const state = sw.dataset.state; const handle = sw.querySelector('.switch-handle'); const labelId = sw.id + '-label'; const labelElement = document.getElementById(labelId); if (!labelElement) return; if (sw.dataset.values) { const values = sw.dataset.values.split(','); const text = state === 'up' ? values[0] : values[1]; labelElement.textContent = text.substring(0, 2).toUpperCase(); } else { labelElement.textContent = state === 'up' ? 'UP' : 'DOWN'; } if (state === 'up') { handle.style.left = `${sw.offsetWidth - handle.offsetWidth - 4}px`; } else { handle.style.left = '2px'; } }

    function updateParameter(knobOrSwitch, newValue, forceUpdate = false) {
        const element = knobOrSwitch;
        const paramPath = element.dataset.param;
        const isKnob = element.classList.contains('knob');
        const isSwitch = element.classList.contains('switch');

        let actualAudioValue; // Value sent to Web Audio node

        // --- Calculate actualAudioValue based on UI input (Mostly as before) ---
        if (isKnob) {
            const min = parseFloat(element.dataset.min);
            const max = parseFloat(element.dataset.max);
            const steps = element.dataset.steps ? element.dataset.steps.split(',') : null;
            const isLog = element.dataset.curve === 'log' && min > 0;
            const numericNewValue = (typeof newValue === 'string' && isNaN(parseFloat(newValue))) ? newValue : parseFloat(newValue);
            let percentageForVisual = 0.5;

            if (steps) {
                const stepIndex = Math.max(0, Math.min(steps.length - 1, Math.round(numericNewValue)));
                const stepValueStr = steps[stepIndex];
                // Determine if step value is a string (waveform, filter type) or number
                if (lfoWaveforms.includes(stepValueStr) || vcoWaveforms.includes(stepValueStr) || FILTER_TYPES.includes(stepValueStr)) {
                    actualAudioValue = stepValueStr;
                } else {
                    // Assume numeric step, or use the index if it's an octave
                    actualAudioValue = isNaN(parseFloat(stepValueStr)) ? stepValueStr : parseFloat(stepValueStr);
                }
                if (paramPath.endsWith('.octave')) actualAudioValue = stepIndex; // Use index for octave param
                element.dataset.value = stepIndex; // Store index in dataset for stepped knobs
                percentageForVisual = steps.length > 1 ? stepIndex / (steps.length - 1) : 0.5;
            } else { // Continuous knobs
                let clampedValue = Math.max(min, Math.min(max, numericNewValue));
                actualAudioValue = clampedValue;
                element.dataset.value = clampedValue.toFixed(5); // Store precise value in dataset
                // Calculate percentage for visual rotation
                if (isLog) {
                    if (clampedValue <= min) percentageForVisual = 0;
                    else if (clampedValue >= max) percentageForVisual = 1;
                    else percentageForVisual = Math.log(clampedValue / min) / Math.log(max / min);
                } else {
                    const range = max - min;
                    percentageForVisual = range > 0 ? (clampedValue - min) / range : 0.5;
                }
                 percentageForVisual = Math.max(0, Math.min(1, isNaN(percentageForVisual) ? 0.5 : percentageForVisual));
            }
            updateKnobVisual(element, percentageForVisual, actualAudioValue);

        } else if (isSwitch) {
            const state = newValue; // 'up' or 'down'
            element.dataset.state = state;
            if (element.dataset.values) {
                const values = element.dataset.values.split(','); // e.g., "highpass,lowpass"
                actualAudioValue = state === 'up' ? values[0] : values[1];
            } else {
                // Default switch behavior (e.g., 1 for 'up', 0 for 'down')
                actualAudioValue = state === 'up' ? 1 : 0;
            }
            updateSwitchVisual(element);
            element.dataset.value = actualAudioValue; // Store the actual audio value
        } else {
            console.warn("updateParameter called on non-control element:", element);
            return;
        }

        // --- Update Internal Params Object (As before) ---
        const parts = paramPath.split('.');
        let currentParamObj = params;
        try {
            for (let i = 0; i < parts.length - 1; i++) {
                if (!currentParamObj[parts[i]]) currentParamObj[parts[i]] = {};
                currentParamObj = currentParamObj[parts[i]];
            }
            const finalKey = parts[parts.length - 1];

            // Handle nested param objects like gain.value or frequency.value
            if (typeof currentParamObj[finalKey] === 'object' && currentParamObj[finalKey] !== null && 'value' in currentParamObj[finalKey]) {
                 currentParamObj[finalKey].value = actualAudioValue;
            } else {
                // Direct assignment for flat params (like delayLevel, reverbLevel, distortionAmount)
                // or simple types (like filter.type, vco.type)
                currentParamObj[finalKey] = actualAudioValue;
            }
        } catch (e) { console.error("Error updating internal params:", paramPath, e); }

        // --- Update Web Audio Node (Revised FX logic) ---
        if (isAudioInitialized && (isAudioResumed || forceUpdate) && audioContext) {
            const now = audioContext.currentTime;
            const fastRampTime = 0.005; // Quick ramp for freq, etc.
            const defaultRampTime = 0.010; // Standard ramp for gain, etc.
            const valueToSet = actualAudioValue; // Use the calculated value

            try {
                // --- LFO (As before) ---
                if (paramPath === 'lfo.frequency.value' && typeof valueToSet === 'number') {
                    if (lfo) lfo.frequency.setTargetAtTime(valueToSet, now, defaultRampTime);
                    if (lfoRandomFrequencyParam) lfoRandomFrequencyParam.setTargetAtTime(valueToSet, now, defaultRampTime);
                } else if (paramPath === 'lfo.type' && typeof valueToSet === 'string') {
                     if (valueToSet === 'random') {
                        if(lfoOscGain) lfoOscGain.gain.setTargetAtTime(0, now, fastRampTime);
                        if(lfoRandomGain) lfoRandomGain.gain.setTargetAtTime(1, now, fastRampTime);
                    } else {
                        if (lfo && ['sine', 'square', 'sawtooth', 'triangle'].includes(valueToSet)) { lfo.type = valueToSet; }
                        if(lfoOscGain) lfoOscGain.gain.setTargetAtTime(1, now, fastRampTime);
                        if(lfoRandomGain) lfoRandomGain.gain.setTargetAtTime(0, now, fastRampTime);
                    }
                }
                // --- Master Gain (As before) ---
                else if (paramPath === 'masterGain.gain.value' && masterGain) {
                    if (audioContext.state === 'running') masterGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                    else masterGain.gain.value = valueToSet; // Set directly if suspended
                }
                // --- Mixer Gains (As before) ---
                else if (paramPath === 'vco1Gain.gain.value' && vco1Gain) vco1Gain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'vco2Gain.gain.value' && vco2Gain) vco2Gain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'noiseGain.gain.value' && noiseGain) noiseGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                // --- LFO Mod Depths (As before) ---
                else if (paramPath === 'vco1LfoGain.gain.value' && vco1LfoGain) vco1LfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'vco2LfoGain.gain.value' && vco2LfoGain) vco2LfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'vcfLfoGain.gain.value' && vcfLfoGain) vcfLfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'vcaLfoGain.gain.value' && vcaLfoGain) vcaLfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                // --- VCF Env Depth (As before) ---
                else if (paramPath === 'vcfEnvGain.gain.value' && vcfEnvGain) vcfEnvGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                // --- Main VCF (As before) ---
                else if (paramPath === 'filter.frequency.value' && filter) filter.frequency.setTargetAtTime(valueToSet, now, fastRampTime);
                else if (paramPath === 'filter.Q.value' && filter) filter.Q.setTargetAtTime(valueToSet, now, defaultRampTime);
                else if (paramPath === 'filter.type' && filter && typeof valueToSet === 'string') filter.type = valueToSet;
                // --- VCO Types (As before) ---
                 else if (paramPath === 'vco1.type' && vco1 && typeof valueToSet === 'string') vco1.type = valueToSet;
                 else if (paramPath === 'vco2.type' && vco2 && typeof valueToSet === 'string') vco2.type = valueToSet;

                // --- FX (REVISED Logic) ---
                else if (paramPath === 'distortionAmount' && typeof valueToSet === 'number') {
                    // Update distortion curve (optional, you could simplify this if pre-gain is enough)
                    if (distortion) distortion.curve = makeDistortionCurve(valueToSet);

                    // Calculate and set Pre-Gain
                    // Map knob value (0-30) to gain (e.g., 1 to 10). Adjust '10' for max gain.
                    const maxPreGain = 50; // <<< TUNE THIS VALUE for maximum intensity boost
                    const preGainValue = 1 + (valueToSet / 30) * (maxPreGain - 1);
                    if (distortionPreGain) {
                        distortionPreGain.gain.setTargetAtTime(preGainValue, now, defaultRampTime);
                    }
                }
                else if (paramPath === 'delayTime.delayTime.value' && delay && typeof valueToSet === 'number') {
                    delay.delayTime.setTargetAtTime(valueToSet, now, defaultRampTime);
                }
                else if (paramPath === 'delayFeedbackGain.gain.value' && delayFeedbackGain && typeof valueToSet === 'number') {
                    delayFeedbackGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                }
                else if (paramPath === 'delayLevel' && delayWetGain && typeof valueToSet === 'number') {
                    // Delay Level knob directly controls the delayWetGain node
                    delayWetGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                }
                 else if (paramPath === 'reverbLevel' && reverbWetGain && typeof valueToSet === 'number') {
                    // Reverb Level knob directly controls the reverbWetGain node
                    // NO BOOST FACTOR APPLIED HERE - it's handled by the routing.
                    reverbWetGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                }

                // --- Tuning/Octave/Detune (As before - only update active notes) ---
                 else if (currentNote !== null && (paramPath === 'vco1.octave' || paramPath === 'vco2.octave')) {
                     const targetOsc1Freq = calculateVcoFrequency(currentFrequency, params.vco1);
                     const targetOsc2Freq = calculateVcoFrequency(currentFrequency, params.vco2);
                     if (vco1) vco1.frequency.setTargetAtTime(targetOsc1Freq, now, fastRampTime);
                     if (vco2) vco2.frequency.setTargetAtTime(targetOsc2Freq, now, fastRampTime);
                 } else if (paramPath === 'masterTune' || paramPath === 'vco2.detune.value') {
                     const totalDetune1 = params.masterTune;
                     const totalDetune2 = params.masterTune + params.vco2.detune.value;
                     if (vco1) vco1.detune.setTargetAtTime(totalDetune1, now, fastRampTime);
                     if (vco2) vco2.detune.setTargetAtTime(totalDetune2, now, fastRampTime);
                 }
                 // ADSR/Portamento params are stored internally and used by envelope/note functions

            } catch (e) { console.error(`Error setting AudioNode param ${paramPath}:`, e, "Value:", valueToSet); }
        }
    }

    // (updateAllKnobs, updateAllSwitches - unchanged)
    function updateAllKnobs(forceUpdate = false) { if (!knobs) knobs = synthPanel.querySelectorAll('.knob'); knobs.forEach(knob => { let initialValueStr = knob.getAttribute('data-value'); let valueToPass; const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null; let currentDatasetValue = knob.dataset.value; if (forceUpdate && initialValueStr !== null) { valueToPass = steps ? parseInt(initialValueStr) : parseFloat(initialValueStr); if(currentDatasetValue === undefined || currentDatasetValue === null) knob.dataset.value = initialValueStr; } else { currentDatasetValue = currentDatasetValue || initialValueStr || '0'; valueToPass = steps ? parseInt(currentDatasetValue) : parseFloat(currentDatasetValue); } updateParameter(knob, valueToPass, forceUpdate); if (!steps) { const displayId = knob.id + '-value'; const displayElement = document.getElementById(displayId); if (displayElement) displayElement.style.display = 'none'; } }); }
    function updateAllSwitches(forceUpdate = false) { if (!switches) switches = synthPanel.querySelectorAll('.switch'); switches.forEach(sw => { const initialOrCurrentState = sw.dataset.state || 'down'; updateParameter(sw, initialOrCurrentState, forceUpdate); }); }

    // ----- EVENT LISTENERS -----
    // (Knob Keyboard Control Helpers: getKnobPercentage, handleKnobInteraction, handleArrowPress, startArrowRepeat, stopArrowRepeat - unchanged)
    let arrowKeyDown = null; let shiftKeyDown = false; let intervalId = null;
    function getKnobPercentage(knob){const min=parseFloat(knob.dataset.min);const max=parseFloat(knob.dataset.max);const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;const isLog=knob.dataset.curve==='log'&&min>0;let currentValueStr=knob.dataset.value;let percentage=0.5;if(currentValueStr===undefined||currentValueStr===null){currentValueStr=knob.getAttribute('data-value')||'0';}let currentValue=parseFloat(currentValueStr);if(steps){const numSteps=steps.length;const stepIndex=Math.round(currentValue);percentage=numSteps>1?stepIndex/(numSteps-1):0.5;}else if(isLog){currentValue=parseFloat(knob.dataset.actualValue||currentValueStr);if(currentValue<=min)percentage=0;else if(currentValue>=max)percentage=1;else if(min>0&&max>min)percentage=Math.log(currentValue/min)/Math.log(max/min);else percentage=0;}else{currentValue=parseFloat(knob.dataset.actualValue||currentValueStr);const range=max-min;percentage=range>0?(currentValue-min)/range:0.5;}if(isNaN(percentage))percentage=0.5;return Math.max(0,Math.min(1,percentage));}
    function handleKnobInteraction(knob,adjustmentFn){const min=parseFloat(knob.dataset.min);const max=parseFloat(knob.dataset.max);const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;const isLog=knob.dataset.curve==='log'&&min>0;let currentPercentage=getKnobPercentage(knob);let newValue;if(steps){const numSteps=steps.length;let currentStepIndex=numSteps>1?Math.round(currentPercentage*(numSteps-1)):0;let stepChange=adjustmentFn(0,1);newValue=currentStepIndex+stepChange;newValue=Math.max(0,Math.min(numSteps-1,Math.round(newValue)));}else{let percentageChange=adjustmentFn(0,0.01);let newPercentage=currentPercentage+percentageChange;newPercentage=Math.max(0,Math.min(1,newPercentage));if(isLog){const epsilon=1e-9;const clampedPercentage=Math.max(epsilon,newPercentage);if(min>0&&max>min)newValue=min*Math.pow(max/min,clampedPercentage);else newValue=(newPercentage>0.5)?max:min;}else{const range=max-min;newValue=min+newPercentage*range;}newValue=Math.max(min,Math.min(max,newValue));}let currentValueInDataStr=knob.dataset.value;if(currentValueInDataStr===undefined||currentValueInDataStr===null)currentValueInDataStr='0';let currentValueInData=parseFloat(currentValueInDataStr);const tolerance=1e-7;if(Math.abs(newValue-currentValueInData)>tolerance){updateParameter(knob,newValue);}}
    function handleArrowPress(knob,direction,isShift){const steps=knob.dataset.steps?knob.dataset.steps.split(','):null;if(steps){const stepChange=(direction==='left'?-1:1)*(isShift?2:1);handleKnobInteraction(knob,(current,step)=>stepChange);}else{const multiplier=isShift?10:1;handleKnobInteraction(knob,(current,basePercentageStep)=>{const effectiveStep=basePercentageStep*multiplier;return direction==='left'?-effectiveStep:effectiveStep;});}}
    function startArrowRepeat(knob,direction,isShift){stopArrowRepeat();handleArrowPress(knob,direction,isShift);intervalId=setInterval(()=>{if(!arrowKeyDown||document.activeElement!==knob){stopArrowRepeat();return;}handleArrowPress(knob,direction,isShift);},75);}
    function stopArrowRepeat(){clearInterval(intervalId);intervalId=null;}

    // (document keydown, keyup, window blur listeners - unchanged)
    document.addEventListener('keydown', async (e) => { if (document.activeElement && document.activeElement.classList.contains('knob')) { const focusedKnob = document.activeElement; if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') { e.preventDefault(); const direction = e.key === 'ArrowLeft' ? 'left' : 'right'; const newShiftState = e.shiftKey; if (arrowKeyDown !== direction || shiftKeyDown !== newShiftState || !intervalId) { arrowKeyDown = direction; shiftKeyDown = newShiftState; startArrowRepeat(focusedKnob, direction, shiftKeyDown); } return; } if (e.key >= '0' && e.key <= '9') { e.preventDefault(); const keyNumber = parseInt(e.key, 10); const min = parseFloat(focusedKnob.dataset.min); const max = parseFloat(focusedKnob.dataset.max); const steps = focusedKnob.dataset.steps ? focusedKnob.dataset.steps.split(',') : null; const isLog = focusedKnob.dataset.curve === 'log' && min > 0; let targetValue; if (steps) { const numSteps = steps.length; if (numSteps === 0) return; let targetIndex = (keyNumber === 0) ? numSteps - 1 : keyNumber - 1; targetIndex = Math.max(0, Math.min(numSteps - 1, targetIndex)); targetValue = targetIndex; } else { let currentActualValueStr = focusedKnob.dataset.actualValue || focusedKnob.dataset.value || '0'; const currentActualValue = parseFloat(currentActualValueStr); const epsilon = 1e-7; let targetPercentage = (keyNumber === 0) ? (Math.abs(currentActualValue - min) < epsilon ? 1.0 : 0.0) : keyNumber / 10.0; if (isLog) { if (min > 0 && max > min) { const clampedPercentage = Math.max(1e-9, targetPercentage); targetValue = min * Math.pow(max / min, clampedPercentage); } else { targetValue = (targetPercentage > 0.5) ? max : min; } } else { const range = max - min; targetValue = min + targetPercentage * range; } targetValue = Math.max(min, Math.min(max, targetValue)); } updateParameter(focusedKnob, targetValue); return; } } if (e.key === 'Shift') shiftKeyDown = true; if (e.key >= '0' && e.key <= '9') return; if (e.metaKey || e.ctrlKey || e.altKey || e.repeat) return; const note = keyToNoteMap[e.code]; if (note && !pressedKeys[e.code]) { e.preventDefault(); let canPlay = isAudioResumed; if (!canPlay && isAudioInitialized) { canPlay = await ensureAudioContextResumed(); } if (canPlay) { pressedKeys[e.code] = true; const freq = midiToFreq(note); noteOn(note, freq); } else if (isAudioInitialized) { console.warn("Audio Context not running."); } else { console.error("Audio not initialized."); } } });
    document.addEventListener('keyup', (e) => { if (document.activeElement && document.activeElement.classList.contains('knob')) { if ((e.key === 'ArrowLeft' && arrowKeyDown === 'left') || (e.key === 'ArrowRight' && arrowKeyDown === 'right')) { arrowKeyDown = null; stopArrowRepeat(); } } if (e.key === 'Shift') { shiftKeyDown = false; if (arrowKeyDown && intervalId && document.activeElement && document.activeElement.classList.contains('knob')) { startArrowRepeat(document.activeElement, arrowKeyDown, false); } } const note = keyToNoteMap[e.code]; if (note && pressedKeys[e.code]) { pressedKeys[e.code] = false; noteOff(note); } });
    window.addEventListener('blur', () => { if (currentNote !== null && audioContext && audioContext.state === 'running') { const now = audioContext.currentTime; if (now !== undefined && now > 0) { if (vcaEnvelopeGain) { vcaEnvelopeGain.gain.cancelScheduledValues(now); vcaEnvelopeGain.gain.setValueAtTime(0.0001, now); } if (filter) { filter.frequency.cancelScheduledValues(now); filter.frequency.setValueAtTime(params.filter.frequency.value, now); } } currentNote = null; currentFrequency = 0; } pressedKeys = {}; arrowKeyDown = null; stopArrowRepeat(); if (isDragging) stopDrag(); });

    // (Mouse Input for Knobs: isDragging, dragKnob, startY, startValue, handleKnobMouseMove, stopDrag, setupKnobListeners - unchanged)
    let isDragging=false;let dragKnob=null;let startY=0;let startValue=0; function handleKnobMouseMove(e){if(!isDragging||!dragKnob)return;e.preventDefault();const currentY=e.clientY;const deltaY=startY-currentY;const steps=dragKnob.dataset.steps?dragKnob.dataset.steps.split(','):null;const min=parseFloat(dragKnob.dataset.min);const max=parseFloat(dragKnob.dataset.max);const isLog=dragKnob.dataset.curve==='log'&&min>0;const paramPath=dragKnob.dataset.param;let startPercentage=startValue;let newValue;if(steps){const pixelsPerStep=20;const totalSteps=steps.length;if(totalSteps<=1)return;const totalDragPixelsForSteps=pixelsPerStep*(totalSteps-1);const percentageChange=totalDragPixelsForSteps>0?(deltaY/totalDragPixelsForSteps):0;let newPercentage=Math.max(0,Math.min(1,startPercentage+percentageChange));newValue=Math.round(newPercentage*(totalSteps-1));let currentStepIndex=Math.round(parseFloat(dragKnob.dataset.value||'0'));if(newValue!==currentStepIndex){updateParameter(dragKnob,newValue);}}else{const dragRangePixels=150;const deltaPercentage=deltaY/dragRangePixels;let newPercentage=Math.max(0,Math.min(1,startPercentage+deltaPercentage));if(isLog){if(min>0&&max>min){const clampedPercentage=Math.max(1e-9,newPercentage);newValue=min*Math.pow(max/min,clampedPercentage);}else{newValue=(newPercentage>0.5)?max:min;}}else{const range=max-min;newValue=min+newPercentage*range;}newValue=Math.max(min,Math.min(max,newValue));let currentActualValue=parseFloat(dragKnob.dataset.actualValue||dragKnob.dataset.value||'0');const tolerance=(max-min)*0.001+1e-7;if(Math.abs(newValue-currentActualValue)>tolerance){if(paramPath==='filter.frequency.value'&&filter&&audioContext){const now=audioContext.currentTime;params.filter.frequency.value=newValue;dragKnob.dataset.value=newValue.toFixed(5);dragKnob.dataset.actualValue=newValue.toFixed(5);updateKnobVisual(dragKnob,newPercentage,newValue);filter.frequency.cancelScheduledValues(now);filter.frequency.setTargetAtTime(newValue,now,0.005);}else{updateParameter(dragKnob,newValue);}}}}
    function stopDrag(e){if(isDragging&&dragKnob){dragKnob.closest('.control-group')?.classList.remove('interacting');if(dragKnob.dataset.param==='filter.frequency.value'){const finalValue=parseFloat(dragKnob.dataset.actualValue||dragKnob.dataset.value||'0');updateParameter(dragKnob,finalValue);}}if(isDragging){isDragging=false;dragKnob=null;document.body.classList.remove('dragging');document.removeEventListener('mousemove',handleKnobMouseMove);document.removeEventListener('mouseup',stopDrag);document.removeEventListener('mouseleave',stopDrag);}} function setupKnobListeners(){if(!knobs)knobs=synthPanel.querySelectorAll('.knob');knobs.forEach(knob=>{const controlGroup=knob.closest('.control-group');const isStepped=knob.hasAttribute('data-steps');const valueDisplayId=knob.id+'-value';const valueDisplay=document.getElementById(valueDisplayId);if(!isStepped&&valueDisplay){knob.addEventListener('focus',()=>{const currentVal=parseFloat(knob.dataset.actualValue||knob.dataset.value||'0');updateKnobValueDisplay(knob,currentVal);valueDisplay.style.display='inline-block';});knob.addEventListener('blur',()=>{if(!isDragging||dragKnob!==knob){valueDisplay.style.display='none';}controlGroup?.classList.remove('interacting');});}knob.addEventListener('mousedown',async(e)=>{let canInteract=isAudioResumed;if(!canInteract&&isAudioInitialized)canInteract=await ensureAudioContextResumed();if(!isAudioInitialized||!canInteract)return;e.preventDefault();isDragging=true;dragKnob=knob;startY=e.clientY;startValue=getKnobPercentage(knob);knob.focus();controlGroup?.classList.add('interacting');if(!isStepped&&valueDisplay){const currentVal=parseFloat(knob.dataset.actualValue||knob.dataset.value||'0');updateKnobValueDisplay(knob,currentVal);valueDisplay.style.display='inline-block';}document.body.classList.add('dragging');document.addEventListener('mousemove',handleKnobMouseMove);document.addEventListener('mouseup',stopDrag);document.addEventListener('mouseleave',stopDrag);});knob.addEventListener('dblclick',async(e)=>{let canInteract=isAudioResumed;if(!canInteract&&isAudioInitialized)canInteract=await ensureAudioContextResumed();if(!isAudioInitialized||!canInteract)return;let defaultValueStr=knob.getAttribute('data-value')||'0';let defaultValue=isStepped?parseInt(defaultValueStr):parseFloat(defaultValueStr);updateParameter(knob,defaultValue);if(!isStepped&&valueDisplay){updateKnobValueDisplay(knob,defaultValue);}});});}

    // (setupSwitchListeners, setupGeneralInteractionListener - unchanged)
    function setupSwitchListeners() { if (!switches) switches = synthPanel.querySelectorAll('.switch'); switches.forEach(sw => { const triggerSwitch = async () => { let canInteract = isAudioResumed; if (!canInteract && isAudioInitialized) canInteract = await ensureAudioContextResumed(); if (!isAudioInitialized || !canInteract) return; const currentState = sw.dataset.state; const newState = currentState === 'up' ? 'down' : 'up'; updateParameter(sw, newState); }; sw.addEventListener('click', triggerSwitch); sw.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); triggerSwitch(); } }); }); }
    function setupGeneralInteractionListener() { synthPanel.addEventListener('pointerdown', () => { if (!isAudioResumed && isAudioInitialized) ensureAudioContextResumed(); }, { capture: true, once: true }); }

    // --- INITIALIZATION ---
    // (DOMContentLoaded listener - unchanged)
    document.addEventListener('DOMContentLoaded', async () => { knobs = synthPanel.querySelectorAll('.knob'); switches = synthPanel.querySelectorAll('.switch'); await initAudio(); if (isAudioInitialized) { setupKnobListeners(); setupSwitchListeners(); setupGeneralInteractionListener(); console.log("Mono Synth Ready."); if (audioContext?.state === 'suspended') { console.warn("REMINDER: Click synth or press key to enable audio."); } } else { console.error("Synth initialization failed. UI listeners not attached."); } });
</script>
</body>
</html>