<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polivoks Web Synth</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono&display=swap');
    </style>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: "Space Mono", sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding-top: 20px; /* Add some padding at the top */
            user-select: none;
            -webkit-user-select: none;
             overflow-x: auto;
        }
        body.dragging {
            cursor: ns-resize; /* Cursor during knob drag */
        }

        .synth-panel {
            background-color: #000000;
            padding: 20px;
            display: grid;
            /* 4 Column Grid Layout */
            grid-template-columns: repeat(4, auto);
            gap: 20px 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, .8);
             min-width: 800px; /* Minimum width for the panel */
             width: max-content; /* Adjust width based on content */
             cursor: default;
        }

        .module {
            padding: 15px 10px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Spacing between elements inside a module */
            min-width: 100px;
            background-color: #111; /* Slightly different background for modules */
        }

        .module-title {
            letter-spacing: .2em;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #ccc;
            width: 100%;
            padding-bottom: 5px;
            text-align: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100%; /* Ensure control groups take width for alignment */
            height: 80px;
        }

         .control-group-horizontal {
             display: flex;
             flex-direction: row;
             align-items: baseline;
             justify-content: space-around;
             gap: 10px;
             width: 100%;
         }

        label {
            font-size: 0.65em;
            letter-spacing: .1em;
            text-transform: uppercase;
            color: #bbb;
            line-height: 1rem;
        }

        .waveform-label {
            font-size: 1.5em; /* Larger symbols for waveforms */
        }

        .knob {
            width: 40px;
            height: 40px;
            background-color: #282828;
            border: 1px solid #555;
            border-radius: 50%;
            position: relative;
            cursor: ns-resize; /* Vertical drag cursor */
            outline: none; /* Remove default focus outline */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }

        .knob:before { /* The indicator line on the knob */
            content: '';
            position: absolute;
            width: 2px;
            height: 12px;
            background-color: #eee;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 50% 15px; /* Rotation origin */
        }

        .knob:focus { /* Highlight when focused */
            box-shadow: 0 0 0 2px #007bff, inset 0 0 5px rgba(0,0,0,0.5);
        }

        /* --- Horizontal Switch --- */
        .switch {
             width: 50px;  /* Wider */
             height: 30px; /* Shorter */
             border: 1px solid #555;
             cursor: pointer;
             position: relative;
             border-radius: 3px;
             overflow: hidden;
             outline: none; /* Remove default focus outline */
        }

        .switch-handle {
            position: absolute;
            top: 2px;      /* Vertical positioning */
            bottom: 2px;   /* Vertical positioning */
            width: 5px;   /* Handle width */
            background-color: #eeeeee;
            border: 1px solid #222;
            border-radius: 2px;
            transition: left 0.1s ease-in-out; /* Animate left property */
        }

         /* State 'up' visually corresponds to the left position (first value) */
         .switch[data-state="up"] .switch-handle {
             left: 40px;
         }
         /* State 'down' visually corresponds to the right position (second value) */
         .switch[data-state="down"] .switch-handle {
             left: 2px; /* 50px total width - 23px handle width - 2px left margin */
         }

        .switch:focus {
             box-shadow: 0 0 0 2px #007bff; /* Highlight on focus */
         }

        /* --- Specific Module Layout (4 columns) --- */
        #lfo-module { grid-column: 1; grid-row: 1; }
        #mixer-module { grid-column: 1; grid-row: 2; }

        #vco1-module { grid-column: 2; grid-row: 1; }
        #vco2-module { grid-column: 2; grid-row: 2; }

        #vcf-module { grid-column: 3; grid-row: 1; }
        #vca-module { grid-column: 3; grid-row: 2; }

        #system-module { grid-column: 4; grid-row: 1 / span 2; }


        /* Adjust VCF/VCA layout */
        #vcf-module, #vca-module {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Adjust gap as needed */
            align-items: center; /* Center align items */
            justify-content: start; /* Align content to the top */
        }
         .adsr-group {
             display: grid;
             grid-template-columns: repeat(4, 1fr); /* 4 equal columns */
             width: 100%;
             gap: 5px 10px; /* Row and column gap */
         }

         /* VCF Specific */
        #vcf-filter-controls {
            display: flex; /* Use flexbox for horizontal alignment */
            justify-content: space-around; /* Space out controls */
            width: 100%;
            gap: 10px; /* Add gap between filter controls */
        }
        #vcf-mod-controls {
            display: flex;
            justify-content: space-around;
             width: 100%;
             gap: 15px; /* Gap between LFO/ADSR mod knobs */
        }

        /* VCA Specific */
        #vca-mod-controls {
             display: flex;
             justify-content: center; /* Center the single LFO Level knob */
             width: 100%;
             margin-top: 10px; /* Add space above VCA Mod controls */
        }

        /* System Module Specific */
        #system-module {
            justify-content: start; /* Align controls to the top */
            gap: 18px; /* Adjust vertical gap between controls */
        }
        /* Make system module title consistent */
        #system-module .module-title {
             margin-bottom: 15px; /* More space after system title */
        }

    </style>
</head>
<body>

<div class="synth-panel" id="synth-panel">
    <!-- LFO -->
    <div class="module" id="lfo-module">
        <div class="module-title">LFO</div>
        <div class="control-group">
            <label for="lfo-speed">Speed</label>
            <div class="knob" id="lfo-speed" data-param="lfo.frequency.value" data-min="0.1" data-max="30" data-value="5" tabindex="0"></div>
        </div>
        <div class="control-group">
            <label for="lfo-waveshape">
                <span class="waveform-label" id="lfo-shape-indicator">⨅</span>
            </label>
            <div class="knob" id="lfo-waveshape" data-param="lfo.type" data-steps="square,sawtooth,triangle,sine" data-value="0" tabindex="0"></div>
        </div>
    </div>

     <!-- Mixer -->
    <div class="module" id="mixer-module">
        <div class="module-title">MIXER</div>
        <div class="control-group"> <!-- Vertical Stack -->
            <label for="vco1-level">VCO1 Level</label>
            <div class="knob" id="vco1-level" data-param="vco1Gain.gain.value" data-min="0" data-max="1" data-value="0.7" tabindex="0"></div>
        </div>
        <div class="control-group"> <!-- Vertical Stack -->
            <label for="vco2-level">VCO2 Level</label>
            <div class="knob" id="vco2-level" data-param="vco2Gain.gain.value" data-min="0" data-max="1" data-value="0.7" tabindex="0"></div>
        </div>
        <div class="control-group"> <!-- Vertical Stack -->
            <label for="noise-level">Noise</label>
            <div class="knob" id="noise-level" data-param="noiseGain.gain.value" data-min="0" data-max="1" data-value="0" tabindex="0"></div>
        </div>
    </div>

    <!-- VCO 1 -->
    <div class="module" id="vco1-module">
        <div class="module-title">VCO 1</div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="vco1-octave">
                    <span class="waveform-label" id="vco1-octave-indicator">8'</span>
                </label>
                <div class="knob" id="vco1-octave" data-param="vco1.octave" data-steps="32,16,8,4,2" data-value="2" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vco1-waveshape">
                    <span class="waveform-label" id="vco1-shape-indicator">⩘</span>
                </label>
                <div class="knob" id="vco1-waveshape" data-param="vco1.type" data-steps="triangle,sawtooth,square,sine" data-value="1" tabindex="0"></div>
            </div>
        </div>
        <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco1-lfo-level">LFO</label>
                <div class="knob" id="vco1-lfo-level" data-param="vco1LfoGain.gain.value" data-min="0" data-max="500" data-value="0" tabindex="0"></div> <!-- LFO pitch mod depth in cents -->
            </div>
        </div>
    </div>

    <!-- VCO 2 -->
    <div class="module" id="vco2-module">
        <div class="module-title">VCO 2</div>
         <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco2-octave">
                    <span class="waveform-label" id="vco2-octave-indicator">8'</span>
                </label>
                <div class="knob" id="vco2-octave" data-param="vco2.octave" data-steps="32,16,8,4,2" data-value="2" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vco2-waveshape">
                    <span class="waveform-label" id="vco2-shape-indicator">⩘</span>
                </label>
                <div class="knob" id="vco2-waveshape" data-param="vco2.type" data-steps="triangle,sawtooth,square,sine" data-value="1" tabindex="0"></div>
            </div>
         </div>
         <div class="control-group-horizontal">
             <div class="control-group">
                <label for="vco2-lfo-level">LFO</label>
                <div class="knob" id="vco2-lfo-level" data-param="vco2LfoGain.gain.value" data-min="0" data-max="500" data-value="0" tabindex="0"></div> <!-- LFO pitch mod depth in cents -->
            </div>
            <div class="control-group">
                <label for="vco2-detune">Detune</label>
                <div class="knob" id="vco2-detune" data-param="vco2.detune.value" data-min="-100" data-max="100" data-value="0" tabindex="0"></div> <!-- Detune in cents -->
            </div>
         </div>
    </div>

    <!-- VCF -->
    <div class="module" id="vcf-module">
        <div class="module-title">VCF</div>
        <div id="vcf-filter-controls"> <!-- Horizontal layout -->
            <div class="control-group">
                <label for="vcf-cutoff">Cutoff</label>
                <div class="knob" id="vcf-cutoff" data-param="filter.frequency.value" data-min="20" data-max="20000" data-value="20000" data-curve="log" tabindex="0"></div>
            </div>
             <div class="control-group">
                <label for="vcf-res">Res</label>
                <div class="knob" id="vcf-res" data-param="filter.Q.value" data-min="0" data-max="30" data-value="1" tabindex="0"></div>
            </div>
             <div class="control-group"> <!-- Container for switch -->
                 <label>Mode</label>
                 <div class="switch" id="vcf-type" data-state="down" data-param="filter.type" data-values="highpass,lowpass" tabindex="0">
                     <div class="switch-handle"></div>
                 </div>
                 <label style="font-size:0.6em;" id="vcf-type-label">LO HI</label>
             </div>
        </div>
        <div class="adsr-group">
            <div class="control-group">
                <label for="vcf-attack">Attack</label>
                <div class="knob" id="vcf-attack" data-param="vcfEnv.attack" data-min="0.005" data-max="2" data-value="0.005" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vcf-decay">Decay</label>
                <div class="knob" id="vcf-decay" data-param="vcfEnv.decay" data-min="0.005" data-max="2" data-value="2" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vcf-sustain">Sustain</label>
                <div class="knob" id="vcf-sustain" data-param="vcfEnv.sustain" data-min="0" data-max="1" data-value="1" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vcf-release">Release</label>
                <div class="knob" id="vcf-release" data-param="vcfEnv.release" data-min="0.005" data-max="5" data-value="0.005" tabindex="0"></div>
            </div>
        </div>
         <div id="vcf-mod-controls">
            <div class="control-group">
                <label for="vcf-lfo-level">LFO</label>
                <div class="knob" id="vcf-lfo-level" data-param="vcfLfoGain.gain.value" data-min="0" data-max="5000" data-value="0" tabindex="0"></div> <!-- LFO Mod depth in Hz -->
            </div>
            <div class="control-group">
                <label for="vcf-adsr-level">ADSR</label>
                <div class="knob" id="vcf-adsr-level" data-param="vcfEnvGain.gain.value" data-min="0" data-max="8000" data-value="0" tabindex="0"></div> <!-- Env Mod depth in Hz -->
            </div>
        </div>
    </div>

    <!-- VCA -->
    <div class="module" id="vca-module">
        <div class="module-title">VCA</div>
         <div class="adsr-group">
            <div class="control-group">
                <label for="vca-attack">Attack</label>
                <div class="knob" id="vca-attack" data-param="vcaEnv.attack" data-min="0.005" data-max="2" data-value="0.01" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vca-decay">Decay</label>
                <div class="knob" id="vca-decay" data-param="vcaEnv.decay" data-min="0.005" data-max="2" data-value="0.1" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vca-sustain">Sustain</label>
                <div class="knob" id="vca-sustain" data-param="vcaEnv.sustain" data-min="0" data-max="1" data-value="1" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="vca-release">Release</label>
                <div class="knob" id="vca-release" data-param="vcaEnv.release" data-min="0.005" data-max="5" data-value="0.2" tabindex="0"></div>
            </div>
        </div>
         <div id="vca-mod-controls">
             <div class="control-group">
                <label for="vca-lfo-level">LFO Level</label>
                <div class="knob" id="vca-lfo-level" data-param="vcaLfoGain.gain.value" data-min="0" data-max="1" data-value="0" tabindex="0"></div> <!-- Tremolo Depth -->
            </div>
         </div>
    </div>

     <!-- System Controls -->
    <div class="module" id="system-module">
         <div class="module-title">SYSTEM & FX</div>
         <div class="control-group">
            <label for="tune">Tune</label>
            <div class="knob" id="tune" data-param="masterTune" data-min="-100" data-max="100" data-value="0" tabindex="0"></div>
        </div>
        <div class="control-group">
            <label for="portamento">Portamento</label>
            <div class="knob" id="portamento" data-param="portamentoTime" data-min="0" data-max="0.5" data-value="0" tabindex="0"></div>
        </div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="delay-time">Dly Time</label>
                <div class="knob" id="delay-time" data-param="delayTime.delayTime.value" data-min="0.05" data-max=".75" data-value="0.15" data-curve="log" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="delay-feedback">Dly Fdbk</label>
                <div class="knob" id="delay-feedback" data-param="delayFeedbackGain.gain.value" data-min="0" data-max="1" data-value=".5" tabindex="0"></div> <!-- Max feedback < 1 -->
            </div>
        </div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="delay-level">Dly Level</label>
                <div class="knob" id="delay-level" data-param="delayLevel" data-min="0" data-max="1" data-value="0" tabindex="0"></div> <!-- Wet/Dry Mix -->
            </div>
            <div class="control-group">
                <label for="reverb-level">Reverb</label>
                <div class="knob" id="reverb-level" data-param="reverbLevel" data-min="0" data-max="1" data-value="0" tabindex="0"></div> <!-- Wet/Dry Mix -->
            </div>
        </div>
        <div class="control-group-horizontal">
            <div class="control-group">
                <label for="volume">Volume</label>
                <div class="knob" id="volume" data-param="masterGain.gain.value" data-min="0" data-max="1" data-value="0.5" tabindex="0"></div>
            </div>
            <div class="control-group">
                <label for="distortion-amount">Drive</label>
                <div class="knob" id="distortion-amount" data-param="distortionAmount" data-min="0" data-max="100" data-value="0" tabindex="0"></div>
            </div>
        </div>
    </div>

</div>
<script>
    // ----- SYNTH PANEL ELEMENTS -----
    const synthPanel = document.getElementById('synth-panel');
    // Query *after* DOM is loaded to ensure all knobs/switches are found
    let knobs;
    let switches;


    // ----- AUDIO CONTEXT & NODES -----
    let audioContext;
    let masterGain;
    let vco1, vco2; // Persistent Oscillators
    let vco1Gain, vco2Gain;
    let noiseSource, noiseGain; // Persistent Noise Source
    let filter;
    let vcaGainNode; // Master VCA controlled by envelope
    let lfo, vco1LfoGain, vco2LfoGain, vcfLfoGain, vcaLfoGain;
    let vcfEnvGain; // Controls VCF Env -> Filter Freq amount

    // --- FX Nodes ---
    let distortion;
    let delay, delayFeedbackGain, delayWetGain, delayDryGain;
    let reverb, reverbWetGain, reverbDryGain;
    let effectsInput; // Point where signal enters FX chain


    let isAudioInitialized = false;
    let isAudioResumed = false; // Tracks if user interaction has successfully resumed context

    // ----- SYNTH PARAMETERS -----
    const params = {
        masterTune: 0, // In cents
        portamentoTime: 0, // Glide time in seconds
        vco1: { octave: 2, type: 'sawtooth' }, // Octave Index
        vco2: { octave: 2, type: 'sawtooth', detune: { value: 0 } }, // Detune in cents
        vcfEnv: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.2 },
        vcaEnv: { attack: 0.01, decay: 0.1, sustain: 1.0, release: 0.2 },
        lfo: { frequency: { value: 5 }, type: 'square' },
        vco1Gain: { gain: { value: 0.7 } },
        vco2Gain: { gain: { value: 0.7 } },
        noiseGain: { gain: { value: 0 } },
        filter: { frequency: { value: 20000 }, Q: { value: 1 }, type: 'lowpass' },
        vco1LfoGain: { gain: { value: 0 } }, // LFO -> VCO1 Pitch Mod Depth (cents)
        vco2LfoGain: { gain: { value: 0 } }, // LFO -> VCO2 Pitch Mod Depth (cents)
        vcfLfoGain: { gain: { value: 0 } }, // LFO -> Filter Freq Mod Depth (Hz)
        vcaLfoGain: { gain: { value: 0 } }, // LFO -> VCA Mod Depth (Gain units 0-1)
        vcfEnvGain: { gain: { value: 4000 } }, // VCF Env -> Filter Freq Mod Depth (Hz)
        // --- FX Params ---
        distortionAmount: 0, // Amount for WaveShaper curve
        delayTime: { delayTime: { value: 0 } }, // Delay time node parameter
        delayFeedbackGain: { gain: { value: 0 } }, // Feedback gain node parameter
        delayLevel: 0, // Wet/Dry mix for delay (0=dry, 1=wet)
        reverbLevel: 0, // Wet/Dry mix for reverb (0=dry, 1=wet)
        // Internal nodes for FX chain control
        delayWetGain: { gain: { value: 0 } },
        delayDryGain: { gain: { value: 1 } },
        reverbWetGain: { gain: { value: 0 } },
        reverbDryGain: { gain: { value: 1 } },
        masterGain: { gain: { value: 0.5 } }
    };

    // ----- CONSTANTS & MAPPINGS -----
    const octaveSteps = [32, 16, 8, 4, 2]; // For display
    const octaveMultipliers = [1/8, 1/4, 1/2, 1, 2]; // For calculation

    const vcoWaveforms = ['triangle', 'sawtooth', 'square', 'sine']; // Possible values
    const vcoShapeIndicators = ['⋀', '⩘', '⨅', '∿']; // Display text
    const lfoWaveforms = ['square', 'sawtooth', 'triangle', 'sine'];
    const lfoShapeIndicators = ['⨅', '⩘', '⋀', '∿'];
    const FILTER_TYPES = ['highpass', 'lowpass']; // For VCF switch

    // ----- MONO SYNTH STATE -----
    let pressedKeys = {}; // Tracks currently physically held keys { 'KeyCode': true }
    let currentNote = null; // The MIDI note number currently sounding (or null if silent)
    let currentFrequency = 0; // Base frequency of the currentNote (before octave/detune)
    const MIDI_C4 = 69; // Reference MIDI note

    const keyToNoteMap = {
        'KeyA': 60, 'KeyW': 61, 'KeyS': 62, 'KeyE': 63, 'KeyD': 64, 'KeyF': 65,
        'KeyT': 66, 'KeyG': 67, 'KeyY': 68, 'KeyH': 69, 'KeyU': 70, 'KeyJ': 71,
        'KeyK': 72,
    };

    // ----- UTILITY FUNCTIONS -----
    function midiToFreq(midiNote) {
        return 440 * Math.pow(2, (midiNote - MIDI_C4) / 12);
    }

    function calculateVcoFrequency(baseFreq, vcoParams) {
        let octaveIndex = vcoParams.octave; // Get the index (should be 0-4)

        // Ensure octaveIndex is a valid number within range, default gracefully if not.
        if (typeof octaveIndex !== 'number' || isNaN(octaveIndex) || octaveIndex < 0 || octaveIndex >= octaveMultipliers.length) {
            console.warn(`calculateVcoFrequency received invalid octaveIndex (${octaveIndex}), defaulting to index 2 (8')`);
            octaveIndex = 2; // Default to 8' index
        }

        const freq = baseFreq * octaveMultipliers[octaveIndex]; // Use the validated/defaulted index
        const safeFreq = Math.max(20, Math.min((audioContext?.sampleRate || 44100) / 2, freq));
        if (!isFinite(safeFreq)) {
            console.error("FATAL: Calculated VCO frequency is non-finite!", freq, baseFreq, octaveIndex);
            return 440; // Return a safe default
        }
        return safeFreq;
    }

    // Distortion curve function
    function makeDistortionCurve(amount) {
        if (!audioContext) return null;
        const k = typeof amount === 'number' ? amount : 0;
        const n_samples = 44100; // Standard sample count
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        let x;
        for (let i = 0; i < n_samples; ++i) {
            x = i * 2 / n_samples - 1;
            // Simple tanh distortion curve: amount adjusts the "hardness"
            curve[i] = Math.tanh(x * (k / 20 + 1)); // Adjust scaling factor as needed
        }
        return curve;
    }


    // ----- AUDIO CONTEXT & INITIALIZATION -----
    async function ensureAudioContextResumed() {
        if (!audioContext) {
            console.error("Attempted to resume context, but it's not initialized.");
            return false;
        }

        try {
            if (audioContext.state === 'running') {
                if (!isAudioResumed) isAudioResumed = true;
                return true;
            }

            if (audioContext.state === 'suspended') {
                console.log("AudioContext suspended. Attempting to resume...");
                await audioContext.resume();

                // Double check the state after resume
                if (audioContext.state === 'running') {
                    console.log("AudioContext Resumed successfully.");
                    isAudioResumed = true;
                    return true;
                }

                // If we get here, resume didn't work as expected
                console.warn("AudioContext state is still not 'running' after resume attempt:", audioContext.state);
                isAudioResumed = false;
                return false;
            }

            // Handle closed or other states
            if (audioContext.state === 'closed') {
                console.error("AudioContext is closed. Reinitializing...");
                isAudioInitialized = false;
                isAudioResumed = false;
                initAudio();
                return false;
            }

            console.warn("AudioContext in unexpected state:", audioContext.state);
            isAudioResumed = false;
            return false;

        } catch (e) {
            console.error("Error resuming AudioContext:", e);
            isAudioResumed = false;
            return false;
        }
    }

    function initAudio() {
        if (isAudioInitialized) return;
        console.log("Initializing AudioContext...");
        try {
            // Create audio context with better error handling
            if (!window.AudioContext && !window.webkitAudioContext) {
                throw new Error("Web Audio API is not supported in this browser");
            }
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Check if context was created successfully
            if (!audioContext) {
                throw new Error("Failed to create AudioContext");
            }

            isAudioInitialized = true;
            console.log("Initial AudioContext State:", audioContext.state);

            // --- Create Core Synth Nodes ---
            try {
                masterGain = audioContext.createGain(); params.masterGain.node = masterGain;
                vco1 = audioContext.createOscillator(); params.vco1.node = vco1;
                vco2 = audioContext.createOscillator(); params.vco2.node = vco2;
                vco1Gain = audioContext.createGain(); params.vco1Gain.node = vco1Gain;
                vco2Gain = audioContext.createGain(); params.vco2Gain.node = vco2Gain;
                noiseGain = audioContext.createGain(); params.noiseGain.node = noiseGain;
                filter = audioContext.createBiquadFilter(); params.filter.node = filter;
                vcaGainNode = audioContext.createGain(); vcaGainNode.gain.value = 0; // Start silent
                lfo = audioContext.createOscillator(); params.lfo.node = lfo;
                vco1LfoGain = audioContext.createGain(); params.vco1LfoGain.node = vco1LfoGain;
                vco2LfoGain = audioContext.createGain(); params.vco2LfoGain.node = vco2LfoGain;
                vcfLfoGain = audioContext.createGain(); params.vcfLfoGain.node = vcfLfoGain;
                vcaLfoGain = audioContext.createGain(); params.vcaLfoGain.node = vcaLfoGain;
                vcfEnvGain = audioContext.createGain(); params.vcfEnvGain.node = vcfEnvGain;

            } catch (e) {
                throw new Error("Failed to create audio nodes: " + e.message);
            }

            // --- Create Noise Source ---
            const bufferSize = audioContext.sampleRate * 2;
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
            noiseSource = audioContext.createBufferSource();
            noiseSource.buffer = noiseBuffer; noiseSource.loop = true;
            params.noiseSource = { node: noiseSource };

            // --- Create FX Nodes ---
            effectsInput = audioContext.createGain(); // Entry point for FX chain
            distortion = audioContext.createWaveShaper(); params.distortion = { node: distortion };
            delay = audioContext.createDelay(2.0); params.delayTime.node = delay; // Max delay 2s
            delayFeedbackGain = audioContext.createGain(); params.delayFeedbackGain.node = delayFeedbackGain;
            delayWetGain = audioContext.createGain(); params.delayWetGain.node = delayWetGain;
            delayDryGain = audioContext.createGain(); params.delayDryGain.node = delayDryGain;
            reverb = audioContext.createConvolver(); params.reverb = { node: reverb };
            reverbWetGain = audioContext.createGain(); params.reverbWetGain.node = reverbWetGain;
            reverbDryGain = audioContext.createGain(); params.reverbDryGain.node = reverbDryGain;


            // --- Set Initial Parameters for Core Synth (using updateAllKnobs/Switches later) ---
            // No need to manually loop through params here anymore,
            // updateAllKnobs(true) will handle setting initial values via updateParameter

            // --- Create Reverb Impulse ---
            const reverbTime = 1.5, decay = 2.0, sampleRate = audioContext.sampleRate;
            const length = sampleRate * reverbTime;
            const impulse = audioContext.createBuffer(1, length, sampleRate); // Mono impulse
            const impulseData = impulse.getChannelData(0); // Get the single channel
            let lastOut = 0.0; const alpha = 0.05; // Simple low-pass filter
            for (let i = 0; i < length; i++) {
                const envelope = Math.pow(1 - i / length, decay);
                const white = Math.random() * 2 - 1;
                const filtered = white * alpha + lastOut * (1 - alpha);
                impulseData[i] = filtered * envelope; lastOut = filtered;
            }
            reverb.buffer = impulse;

            // --- Connect Audio Graph ---
            // LFO -> Mod Targets
            lfo.connect(vco1LfoGain); lfo.connect(vco2LfoGain);
            lfo.connect(vcfLfoGain); lfo.connect(vcaLfoGain);
            vco1LfoGain.connect(vco1.detune);
            vco2LfoGain.connect(vco2.detune);
            vcfLfoGain.connect(filter.frequency);
            vcaLfoGain.connect(vcaGainNode.gain); // LFO modulates VCA gain directly

            // VCF Envelope -> Filter Freq
            vcfEnvGain.connect(filter.frequency); // Amount is controlled by vcfEnvGain.gain

            // Oscillators & Noise -> Mixer -> Filter
            vco1.connect(vco1Gain);
            vco2.connect(vco2Gain);
            noiseSource.connect(noiseGain);
            vco1Gain.connect(filter);
            vco2Gain.connect(filter);
            noiseGain.connect(filter);

            // Filter -> VCA
            filter.connect(vcaGainNode);

            // VCA -> FX Chain Input
            vcaGainNode.connect(effectsInput);

            // --- FX Chain Connections ---
            // Input -> Distortion
            effectsInput.connect(distortion);

            // Distortion -> Delay (Split for Wet/Dry)
            distortion.connect(delayDryGain); // Dry Path through Delay section
            distortion.connect(delay);        // Wet Path into Delay node

            // Delay Feedback Loop
            delay.connect(delayFeedbackGain);
            delayFeedbackGain.connect(delay);

            // Delay -> Delay Wet Gain
            delay.connect(delayWetGain);

            // Delay Dry/Wet -> Reverb (Split for Wet/Dry)
            delayDryGain.connect(reverbDryGain); // Delay Dry feeds Reverb Dry
            delayWetGain.connect(reverbDryGain); // Delay Wet also feeds Reverb Dry (mix before reverb)

            delayDryGain.connect(reverb);       // Delay Dry feeds Reverb input
            delayWetGain.connect(reverb);       // Delay Wet feeds Reverb input

            // Reverb -> Reverb Wet Gain
            reverb.connect(reverbWetGain);

            // Reverb Dry/Wet -> Master Gain
            reverbDryGain.connect(masterGain);
            reverbWetGain.connect(masterGain);

            // Master Gain -> Destination
            masterGain.connect(audioContext.destination);

            // --- Start Persistent Oscillators ---
            lfo.start();
            vco1.start();
            vco2.start();
            noiseSource.start();

            // --- Final State Check ---
            if (audioContext.state === 'running') {
                isAudioResumed = true;
                console.log("Audio graph initialized and context is running.");
            } else {
                isAudioResumed = false;
                console.log("Audio graph initialized, but context is suspended. Requires user interaction.");
            }

            // !!! CRITICAL: Initialize UI and set initial audio node values HERE !!!
            updateAllKnobs(true); // Initialize UI based on params, force audio node updates
            updateAllSwitches(true); // Initialize switches, force audio node updates

        } catch (e) {
            console.error("Error initializing Web Audio API:", e);
            isAudioInitialized = false;
            // Show a more informative error message
            const errorMsg = "Web Audio API initialization failed: " + e.message +
                            "\nPlease ensure you're using a modern browser and try refreshing the page.";
            alert(errorMsg);
        }
    }

    // ----- ENVELOPE FUNCTIONS -----
    function triggerEnvelope(envParams, targetParam, sustainValue, now, isVcf = false) {
        if (!audioContext || !targetParam) return;
        const { attack, decay } = envParams;
        // Use very small minimum values to prevent issues with zero times
        const safeAttack = Math.max(0.001, attack);
        const safeDecay = Math.max(0.001, decay);

        targetParam.cancelScheduledValues(now);

        if (isVcf) {
            // VCF Envelope controls frequency
            // Read the *current* base frequency directly from the param object (set by the knob)
            const knobBaseFreq = params.filter.frequency.value;
            const envModAmount = params.vcfEnvGain.gain.value; // How much env affects cutoff
            const baseFreqWithKeyFollow = Math.max(20, knobBaseFreq); // Use knob value directly (min 20Hz)
            const attackPeakFreq = baseFreqWithKeyFollow + envModAmount;
            const sustainLevelFreq = baseFreqWithKeyFollow + (sustainValue * envModAmount);

            // Clamp values to valid frequency range
            const nyquist = audioContext.sampleRate / 2;
            const clampedBaseFreq = Math.min(nyquist, Math.max(20, baseFreqWithKeyFollow));
            const clampedPeakFreq = Math.min(nyquist, Math.max(20, attackPeakFreq));
            const clampedSustainFreq = Math.min(nyquist, Math.max(20, sustainLevelFreq));

            // Schedule envelope ramps
            // Set initial value to base frequency (important!)
            targetParam.setValueAtTime(clampedBaseFreq, now);
            targetParam.linearRampToValueAtTime(clampedPeakFreq, now + safeAttack); // Ramp up during attack
            targetParam.linearRampToValueAtTime(clampedSustainFreq, now + safeAttack + safeDecay); // Ramp down to sustain

        } else { // VCA Envelope controls gain
            const peakVal = 1.0;
            const sustainLevel = Math.max(0.0001, sustainValue); // Minimum sustain level > 0
            targetParam.setValueAtTime(0.0001, now); // Start near zero
            targetParam.linearRampToValueAtTime(peakVal, now + safeAttack); // Ramp up during attack
            targetParam.linearRampToValueAtTime(sustainLevel, now + safeAttack + safeDecay); // Ramp down to sustain
        }
    }

    function releaseEnvelope(envParams, targetParam, now, isVcf = false) {
        if (!audioContext || !targetParam) return;
        const { release } = envParams;
        const safeRelease = Math.max(0.001, release); // Minimum release time

        targetParam.cancelScheduledValues(now); // Cancel any future ramps

        let releaseTargetValue;
        let actualReleaseTime = safeRelease; // Base release time from knob

        if (isVcf) {
            // VCF release targets the base cutoff frequency from the knob (param object)
            const knobBaseFreq = params.filter.frequency.value;
            const baseFreqWithKeyFollow = Math.max(20, knobBaseFreq);
            releaseTargetValue = Math.min(audioContext.sampleRate / 2, Math.max(20, baseFreqWithKeyFollow));
        } else { // VCA release targets silence (near zero)
            releaseTargetValue = 0.0001;
        }

        // Capture current value before scheduling the final ramp down
        // Using setValueAtTime ensures the ramp starts from the correct current value
        targetParam.setValueAtTime(targetParam.value, now);
        targetParam.linearRampToValueAtTime(releaseTargetValue, now + actualReleaseTime);
    }

    function triggerEnvelopes(now) {
         if (!filter || !vcaGainNode) return;
         // Trigger VCF envelope targeting filter frequency
         triggerEnvelope(params.vcfEnv, filter.frequency, params.vcfEnv.sustain, now, true);
         // Trigger VCA envelope targeting VCA gain
         triggerEnvelope(params.vcaEnv, vcaGainNode.gain, params.vcaEnv.sustain, now, false);
    }

    function releaseEnvelopes(now) {
         if (!filter || !vcaGainNode) return;
         // Release VCF envelope targeting filter frequency
         releaseEnvelope(params.vcfEnv, filter.frequency, now, true);
         // Release VCA envelope targeting VCA gain
         releaseEnvelope(params.vcaEnv, vcaGainNode.gain, now, false);
    }


    // ----- MONOPHONIC NOTE HANDLING -----

    function noteOn(note, freq) {
        if (!audioContext || audioContext.state !== 'running' || !vco1 || !vco2) {
            console.warn("noteOn called but audio context not running or VCOs not ready!");
            return;
        }

        const now = audioContext.currentTime;
        const portamento = params.portamentoTime > 0.005 ? params.portamentoTime : 0; // Apply glide if > 5ms

        // Calculate target frequencies based on note, octave, and tuning
        const targetOsc1Freq = calculateVcoFrequency(freq, params.vco1);
        const targetOsc2Freq = calculateVcoFrequency(freq, params.vco2);

        if (currentNote !== null) { // Legato transition: Glide from previous note
            currentFrequency = freq;
            currentNote = note;

            if (portamento > 0) { // Glide to new pitch
                vco1.frequency.cancelScheduledValues(now);
                vco2.frequency.cancelScheduledValues(now);
                // Use setTargetAtTime for exponential glide (adjust time constant as needed)
                vco1.frequency.setTargetAtTime(targetOsc1Freq, now, portamento / 4);
                vco2.frequency.setTargetAtTime(targetOsc2Freq, now, portamento / 4);
            } else { // No glide, jump immediately
                vco1.frequency.cancelScheduledValues(now);
                vco2.frequency.cancelScheduledValues(now);
                vco1.frequency.setValueAtTime(targetOsc1Freq, now);
                vco2.frequency.setValueAtTime(targetOsc2Freq, now);
            }
            // Re-trigger envelopes for legato note articulation
            triggerEnvelopes(now);

        } else { // First note: Start from silence
            currentFrequency = freq;
            currentNote = note;

            // Set initial frequency immediately (no glide needed)
            vco1.frequency.cancelScheduledValues(now);
            vco2.frequency.cancelScheduledValues(now);
            vco1.frequency.setValueAtTime(targetOsc1Freq, now);
            vco2.frequency.setValueAtTime(targetOsc2Freq, now);
            // Trigger envelopes to start the sound
            triggerEnvelopes(now);
        }
    }

    function noteOff(note) {
        if (!isAudioInitialized || !isAudioResumed || currentNote === null || !vco1 || !vco2) {
            return; // Ignore if synth isn't ready or no note is playing
        }

        // Find if any other keys are still held down
        const remainingHeldCodes = Object.keys(pressedKeys).filter(code => pressedKeys[code] && keyToNoteMap[code]);

        // Only process note off if the released key corresponds to the currently sounding note
        if (note === currentNote) {
            if (remainingHeldCodes.length > 0) {
                // Legato: Transition to the last pressed remaining key (Last Note Priority)
                let lastNote = -1;
                let lastNoteFreq = 0;
                // Find the note corresponding to the last key in the filtered list
                remainingHeldCodes.forEach(code => {
                    const heldNote = keyToNoteMap[code];
                    lastNote = heldNote; // Keep track of the last one found
                    lastNoteFreq = midiToFreq(lastNote);
                });

                const now = audioContext.currentTime;
                const portamento = params.portamentoTime > 0.005 ? params.portamentoTime : 0;

                // Calculate target frequencies for the new note
                const targetOsc1Freq = calculateVcoFrequency(lastNoteFreq, params.vco1);
                const targetOsc2Freq = calculateVcoFrequency(lastNoteFreq, params.vco2);

                // Update synth state
                currentFrequency = lastNoteFreq;
                currentNote = lastNote;

                // Glide or jump to the new note's pitch
                if (portamento > 0) {
                    vco1.frequency.cancelScheduledValues(now);
                    vco2.frequency.cancelScheduledValues(now);
                    vco1.frequency.setTargetAtTime(targetOsc1Freq, now, portamento / 4);
                    vco2.frequency.setTargetAtTime(targetOsc2Freq, now, portamento / 4);
                } else {
                    vco1.frequency.cancelScheduledValues(now);
                    vco2.frequency.cancelScheduledValues(now);
                    vco1.frequency.setValueAtTime(targetOsc1Freq, now);
                    vco2.frequency.setValueAtTime(targetOsc2Freq, now);
                }
                // IMPORTANT: Do *not* re-trigger envelopes for legato transition. Let them continue.

            } else {
                // Last key released: Start the release phase of the envelopes
                const now = audioContext.currentTime;
                releaseEnvelopes(now);
                currentNote = null; // No note is actively sounding
                currentFrequency = 0;
            }
        }
        // If the released key wasn't the currently sounding one, do nothing (another key has priority)
    }


    // ----- UI UPDATE FUNCTIONS -----

    // MODIFIED: Takes valueForRotation which is ALWAYS the linear percentage (0-1)
    // Also takes actualAudioValue for storage/display purposes.
    function updateKnobVisual(knob, valueForRotation, actualAudioValue) {
        // Store the actual audio value back to the dataset for reference/debugging
        // Note: data-value itself will hold the audio value for log knobs now,
        // but this is good for consistency/debugging.
        knob.dataset.actualValue = typeof actualAudioValue === 'number' ?
            actualAudioValue.toFixed(5) :
            actualAudioValue;

        const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null;

        // valueForRotation IS the percentage (0-1)
        let percentage = Math.max(0, Math.min(1, valueForRotation));

        // Update step-based labels if applicable (using percentage to find index)
        if (steps) {
            const stepIndex = Math.round(percentage * (steps.length - 1));
            if (knob.id === 'vco1-waveshape') document.getElementById('vco1-shape-indicator').textContent = vcoShapeIndicators[stepIndex] || '?';
            if (knob.id === 'vco2-waveshape') document.getElementById('vco2-shape-indicator').textContent = vcoShapeIndicators[stepIndex] || '?';
            if (knob.id === 'lfo-waveshape') document.getElementById('lfo-shape-indicator').textContent = lfoShapeIndicators[stepIndex] || '?';
            if (knob.id === 'vco1-octave') document.getElementById('vco1-octave-indicator').textContent = octaveSteps[stepIndex] ? octaveSteps[stepIndex] + "'" : '?';
            if (knob.id === 'vco2-octave') document.getElementById('vco2-octave-indicator').textContent = octaveSteps[stepIndex] ? octaveSteps[stepIndex] + "'" : '?';
        }

        // Calculate rotation based on the linear percentage
        const rotation = -135 + (percentage * 270); // Map 0-1 linearly to -135deg to +135deg
        knob.style.transform = `rotate(${rotation}deg)`;
    }

    function updateSwitchVisual(sw) {
        const state = sw.dataset.state; // 'up' or 'down'
        const handle = sw.querySelector('.switch-handle');

        // Update associated label text if one exists (e.g., vcf-type-label)
        const labelId = sw.id + '-label';
        const labelElement = document.getElementById(labelId);
        if (!labelElement) return;

        if (sw.dataset.values) { // If values are defined (e.g., "highpass,lowpass")
            const values = sw.dataset.values.split(',');
            const text = state === 'up' ? values[0] : values[1]; // 'up' maps to first value
            // Display first 2 chars (e.g., HI, LO) - Adjusted from 3
            labelElement.textContent = text.substring(0,2).toUpperCase();
        } else { // Default label update if no specific values
            labelElement.textContent = state === 'up' ? 'UP' : 'DOWN';
        }
    }

    // Main function to update synth parameter based on UI interaction
    // MODIFIED: For log knobs, newValue IS the target audio value.
    //           Percentage is calculated internally for visual updates.
    function updateParameter(knobOrSwitch, newValue, forceUpdate = false) {
        const element = knobOrSwitch;
        const paramPath = element.dataset.param;
        const isKnob = element.classList.contains('knob');
        const isSwitch = element.classList.contains('switch');

        let uiValue = newValue; // The value representing the UI state (value, index, 'up'/'down')
        let actualAudioValue; // The value used by the AudioNode API or stored in params
        let percentageForVisual = 0.5; // Default percentage for visual update

        if (isKnob) {
            const min = parseFloat(element.dataset.min);
            const max = parseFloat(element.dataset.max);
            const steps = element.dataset.steps ? element.dataset.steps.split(',') : null;
            const isLog = element.dataset.curve === 'log' && min > 0;
            const numericNewValue = parseFloat(newValue); // Should be audio value or index

            if (steps) { // Stepped Knob (Waveforms, Octaves) - No change needed here
                const stepIndex = Math.max(0, Math.min(steps.length - 1, Math.round(numericNewValue)));
                uiValue = stepIndex; // UI value is the index
                const stepValueStr = steps[stepIndex];
                actualAudioValue = isNaN(parseFloat(stepValueStr)) ? stepValueStr : parseFloat(stepValueStr);
                if (paramPath.endsWith('.octave')) actualAudioValue = uiValue; // Store index for octave
                element.dataset.value = uiValue; // Store index in dataset
                // Calculate percentage for visual
                percentageForVisual = steps.length > 1 ? stepIndex / (steps.length - 1) : 0.5;
            } else if (isLog) { // Logarithmic Knob - *** MAJOR CHANGE HERE ***
                // newValue (uiValue) IS the target audio value
                uiValue = Math.max(min, Math.min(max, numericNewValue)); // Clamp audio value
                actualAudioValue = uiValue;
                element.dataset.value = uiValue; // Store actual audio value in dataset

                // Calculate the linear percentage (0-1) JUST for the visual update
                if (uiValue <= min) {
                    percentageForVisual = 0;
                } else if (uiValue >= max) {
                     percentageForVisual = 1;
                } else {
                    // Inverse calculation: value to percentage
                    percentageForVisual = Math.log(uiValue / min) / Math.log(max / min);
                }
                percentageForVisual = Math.max(0, Math.min(1, percentageForVisual)); // Clamp 0-1

            } else { // Linear Knob - No change needed here
                uiValue = Math.max(min, Math.min(max, numericNewValue)); // Clamp linear value
                actualAudioValue = uiValue;
                element.dataset.value = uiValue; // Store linear value in dataset
                // Calculate percentage for visual
                const range = max - min;
                percentageForVisual = range !== 0 ? (actualAudioValue - min) / range : 0.5;
            }
            // Pass the calculated percentage for rotation, and the audio value for reference
            updateKnobVisual(element, percentageForVisual, actualAudioValue);

        } else if (isSwitch) { // Switch - No change needed here
            const state = newValue; // 'up' or 'down'
            element.dataset.state = state;
            if (element.dataset.values) {
                const values = element.dataset.values.split(',');
                actualAudioValue = state === 'up' ? values[0] : values[1];
            } else {
                actualAudioValue = state === 'up' ? 1 : 0;
            }
            updateSwitchVisual(element); // Update visual state and label
            uiValue = actualAudioValue; // For switches, UI value often matches audio value string
            element.dataset.value = uiValue; // Store the derived value
        }

        // --- Update Internal Params Object --- (Logic remains the same, uses actualAudioValue)
        const parts = paramPath.split('.');
        let currentParamObj = params;
        try {
            for (let i = 0; i < parts.length - 1; i++) {
                if (!currentParamObj[parts[i]]) currentParamObj[parts[i]] = {};
                currentParamObj = currentParamObj[parts[i]];
            }
            const finalKey = parts[parts.length - 1];

             if (finalKey === 'octave' && isKnob) {
                 currentParamObj[finalKey] = actualAudioValue; // Store the index
            } else if (typeof currentParamObj[finalKey] === 'object' && currentParamObj[finalKey] !== null && 'value' in currentParamObj[finalKey] && typeof actualAudioValue === 'number') {
                 currentParamObj[finalKey].value = actualAudioValue;
            } else if (typeof currentParamObj[finalKey] === 'object' && currentParamObj[finalKey] !== null && finalKey === 'detune' && 'value' in currentParamObj[finalKey] && typeof actualAudioValue === 'number') {
                 // Special case for VCO2 detune nested object
                 currentParamObj[finalKey].value = actualAudioValue;
            } else {
                currentParamObj[finalKey] = actualAudioValue;
            }
        } catch (e) { console.warn("Error updating internal params:", paramPath, e); }

        // --- Update Web Audio Node --- (Logic remains the same, uses actualAudioValue)
        if (isAudioInitialized && (isAudioResumed || forceUpdate) && audioContext) {
            const now = audioContext.currentTime;
            // Use a slightly shorter ramp time for controls that need responsiveness (like filter cutoff)
            const fastRampTime = 0.005;
            const defaultRampTime = 0.010;

            try {
                 const valueToSet = actualAudioValue; // Use the final calculated audio value

                 // Use appropriate ramp times
                 if (paramPath === 'masterGain.gain.value' && masterGain) masterGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vco1Gain.gain.value' && vco1Gain) vco1Gain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vco2Gain.gain.value' && vco2Gain) vco2Gain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'noiseGain.gain.value' && noiseGain) noiseGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vco1LfoGain.gain.value' && vco1LfoGain) vco1LfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vco2LfoGain.gain.value' && vco2LfoGain) vco2LfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vcfLfoGain.gain.value' && vcfLfoGain) vcfLfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vcaLfoGain.gain.value' && vcaLfoGain) vcaLfoGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'vcfEnvGain.gain.value' && vcfEnvGain) vcfEnvGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'filter.frequency.value' && filter) filter.frequency.setTargetAtTime(valueToSet, now, fastRampTime); // Use faster ramp for cutoff
                 else if (paramPath === 'filter.Q.value' && filter) filter.Q.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'filter.type' && filter) filter.type = valueToSet; // No ramp for type change
                 else if (paramPath === 'lfo.frequency.value' && lfo) lfo.frequency.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'lfo.type' && lfo) lfo.type = valueToSet; // No ramp
                 else if (paramPath === 'vco1.type' && vco1) vco1.type = valueToSet; // No ramp
                 else if (paramPath === 'vco2.type' && vco2) vco2.type = valueToSet; // No ramp
                 else if (paramPath === 'distortionAmount' && distortion) distortion.curve = makeDistortionCurve(valueToSet); // No ramp
                 else if (paramPath === 'delayTime.delayTime.value' && delay) delay.delayTime.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'delayFeedbackGain.gain.value' && delayFeedbackGain) delayFeedbackGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                 else if (paramPath === 'delayLevel') {
                     if (delayWetGain) delayWetGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                     if (delayDryGain) delayDryGain.gain.setTargetAtTime(1 - valueToSet, now, defaultRampTime);
                 }
                 else if (paramPath === 'reverbLevel') {
                     if (reverbWetGain) reverbWetGain.gain.setTargetAtTime(valueToSet, now, defaultRampTime);
                     if (reverbDryGain) reverbDryGain.gain.setTargetAtTime(1 - valueToSet, now, defaultRampTime);
                 }
                 else if ((paramPath === 'vco1.octave' || paramPath === 'vco2.octave') && currentNote !== null) {
                     // Update frequency if a note is playing
                     const targetOsc1Freq = calculateVcoFrequency(currentFrequency, params.vco1);
                     const targetOsc2Freq = calculateVcoFrequency(currentFrequency, params.vco2);
                     if (vco1) vco1.frequency.setTargetAtTime(targetOsc1Freq, now, defaultRampTime);
                     if (vco2) vco2.frequency.setTargetAtTime(targetOsc2Freq, now, defaultRampTime);
                 }
                 else if ((paramPath === 'masterTune' || paramPath === 'vco2.detune.value')) {
                    // Update detune values
                     if (vco1) vco1.detune.setTargetAtTime(params.masterTune, now, defaultRampTime);
                     if (vco2) vco2.detune.setTargetAtTime(params.masterTune + params.vco2.detune.value, now, defaultRampTime);
                 }
                 // ADSR parameters don't directly control AudioParams, they are read by envelope functions
                 // Portamento time also doesn't control an AudioParam directly

            } catch (e) { console.error(`Error setting AudioNode param ${paramPath}:`, e, "Value:", valueToSet); }
        }
    }

    // Initialize or update all knobs based on their data attributes
    function updateAllKnobs(forceUpdate = false) {
        if (!knobs) knobs = synthPanel.querySelectorAll('.knob');
        knobs.forEach(knob => {
            // Get initial *audio* value (or index for stepped) from HTML attribute
            let initialValueStr = knob.getAttribute('data-value');
            let valueToPass; // The initial value/index for updateParameter

            const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null;

            if (forceUpdate && initialValueStr !== null) {
                 if (steps) {
                     valueToPass = parseInt(initialValueStr); // Pass index for stepped
                 } else {
                     valueToPass = parseFloat(initialValueStr); // Pass audio value for linear/log
                 }
            } else {
                 // If not forcing, use the current value in the dataset
                 const currentDatasetValue = knob.dataset.value || initialValueStr || '0';
                 if (steps) {
                     valueToPass = parseInt(currentDatasetValue);
                 } else {
                      valueToPass = parseFloat(currentDatasetValue);
                 }
            }

            // On init, always use forceUpdate=true in call to updateParameter
            // This ensures audio nodes get set even if context is suspended
            updateParameter(knob, valueToPass, true);
        });
    }


    // Initialize or update all switches based on their data attributes
    function updateAllSwitches(forceUpdate = false) {
         if (!switches) switches = synthPanel.querySelectorAll('.switch'); // Ensure switches are selected
         switches.forEach(sw => {
            const state = sw.dataset.state || 'down'; // Default to 'down' if not set
            updateParameter(sw, state, forceUpdate);
        });
    }

    // ----- EVENT LISTENERS -----

    // -- Keyboard Input for Notes and Controls --
    let arrowKeyDown = null; // Tracks which arrow key ('left' or 'right') is held for knob control
    let shiftKeyDown = false; // Tracks if Shift key is held for faster knob adjustment
    let intervalId = null; // Stores interval timer for repeating knob adjustments

    // Helper function to get the current percentage for any knob type
    function getKnobPercentage(knob) {
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null;
        const isLog = knob.dataset.curve === 'log' && min > 0;
        let currentValueStr = knob.dataset.value; // Read current value/index string
        let percentage = 0.5; // Default

        if (currentValueStr === undefined || currentValueStr === null) {
            console.warn("Knob data-value is missing for percentage calculation:", knob.id);
            currentValueStr = knob.getAttribute('data-value') || '0'; // Fallback to attribute
        }

        let currentValue = parseFloat(currentValueStr);

        if (steps) {
            const stepIndex = Math.round(currentValue);
            percentage = steps.length > 1 ? stepIndex / (steps.length - 1) : 0.5;
        } else if (isLog) {
            if (currentValue <= min) percentage = 0;
            else if (currentValue >= max) percentage = 1;
            else percentage = Math.log(currentValue / min) / Math.log(max / min);
        } else { // Linear
             const range = max - min;
             percentage = range > 0 ? (currentValue - min) / range : 0.5;
        }
        // Add safety check for NaN
        if (isNaN(percentage)) {
            console.error("Calculated percentage is NaN for knob:", knob.id, "Value:", currentValue);
            percentage = 0.5; // Reset to default if calculation failed
        }
        return Math.max(0, Math.min(1, percentage)); // Clamp 0-1
    }


    // Helper function (modified for log knobs)
    // adjustmentFn now calculates the *change in percentage*
    function handleKnobInteraction(knob, adjustmentFn) {
        const min = parseFloat(knob.dataset.min);
        const max = parseFloat(knob.dataset.max);
        const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null;
        const isLog = knob.dataset.curve === 'log' && min > 0;

        let currentPercentage = getKnobPercentage(knob); // Get current position as 0-1
        let newValue; // This will be the new audio value or index

        if (steps) { // Stepped Knob
            let currentStepIndex = Math.round(currentPercentage * (steps.length - 1));
            // adjustmentFn provides the *change* in steps (+1, -1)
            let stepChange = adjustmentFn(0, 1); // Pass dummy step size, get step change
            newValue = currentStepIndex + stepChange;
            newValue = Math.max(0, Math.min(steps.length - 1, Math.round(newValue))); // Clamp index
        } else { // Linear or Logarithmic - work with percentages
            // adjustmentFn provides the *change* in percentage (+0.01, -0.01 etc.)
            let percentageChange = adjustmentFn(0, 0.01); // Pass base percentage step, get percentage change
            let newPercentage = currentPercentage + percentageChange;
            newPercentage = Math.max(0, Math.min(1, newPercentage)); // Clamp percentage 0-1

            if (isLog) { // Convert percentage back to log audio value
                 newValue = min * Math.pow(max / min, newPercentage);
            } else { // Convert percentage back to linear audio value
                const range = max - min;
                newValue = min + newPercentage * range;
            }
             // Clamp final audio value just in case
             newValue = Math.max(min, Math.min(max, newValue));
        }

        // Check for actual change before updating (compare against current data-value)
        let currentValueInDataStr = knob.dataset.value;
        if (currentValueInDataStr === undefined || currentValueInDataStr === null) currentValueInDataStr = '0'; // Handle missing data-value
        let currentValueInData = parseFloat(currentValueInDataStr);

        // Use a small tolerance for floating point comparisons
        const tolerance = 1e-7;
        if (Math.abs(newValue - currentValueInData) > tolerance) {
             updateParameter(knob, newValue);
        }
    }

    // Handles a single arrow key press for the focused knob (MODIFIED for percentage)
    function handleArrowPress(knob, direction, isShift) {
        const steps = knob.dataset.steps ? knob.dataset.steps.split(',') : null;
        const isLog = knob.dataset.curve === 'log' && parseFloat(knob.dataset.min) > 0;

        if (steps) { // Stepped
            const stepChange = (direction === 'left' ? -1 : 1) * (isShift ? 2 : 1);
            // adjustmentFn returns the step change directly
            handleKnobInteraction(knob, (current, step) => stepChange);
        } else { // Linear or Logarithmic - adjust percentage
            const multiplier = isShift ? 10 : 1; // Shift increases step size
            // adjustmentFn returns the *percentage change*
            handleKnobInteraction(knob, (current, basePercentageStep) => {
                const effectiveStep = basePercentageStep * multiplier;
                return direction === 'left' ? -effectiveStep : effectiveStep;
            });
        }
    }

    // Starts repeating arrow key adjustments
    function startArrowRepeat(knob, direction, isShift) {
        stopArrowRepeat(); // Clear any existing interval
        handleArrowPress(knob, direction, isShift); // Trigger one adjustment immediately
        intervalId = setInterval(() => { // Start repeating
            if (!arrowKeyDown) { // Stop if key is released
                 stopArrowRepeat();
                 return;
            }
            // Check if the element still has focus
            if (document.activeElement !== knob) {
                stopArrowRepeat();
                return;
            }
            handleArrowPress(knob, direction, isShift); // Adjust again
        }, 75); // Repeat speed (milliseconds)
    }

    // Stops repeating arrow key adjustments
    function stopArrowRepeat() {
        clearInterval(intervalId);
        intervalId = null;
    }

    // Global keydown listener
    document.addEventListener('keydown', async (e) => {
        // --- Knob Control with Arrow Keys ---
        if (document.activeElement && document.activeElement.classList.contains('knob')) {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault(); // Prevent page scroll
                const direction = e.key === 'ArrowLeft' ? 'left' : 'right';
                const newShiftState = e.shiftKey;
                // Start repeating only if state changes or it's not already repeating
                if (arrowKeyDown !== direction || shiftKeyDown !== newShiftState || !intervalId) {
                    arrowKeyDown = direction;
                    shiftKeyDown = newShiftState;
                    startArrowRepeat(document.activeElement, direction, shiftKeyDown);
                }
                return; // Don't process as note if controlling knob
            }
        }
        // Track shift key state globally
         if (e.key === 'Shift') shiftKeyDown = true;

        // --- Note Playing ---
        // Ignore if modifier keys are held or if it's a repeat event
        if (e.metaKey || e.ctrlKey || e.altKey || e.repeat) return;

        const note = keyToNoteMap[e.code]; // Map keyboard code to MIDI note
        if (!note || pressedKeys[e.code]) return; // Ignore unmapped keys or already pressed keys

        // Prevent default key actions only if it's a note key
        if (note) e.preventDefault();

        // Ensure audio context is running before playing
        let canPlay = isAudioResumed;
        if (!canPlay && isAudioInitialized) {
            canPlay = await ensureAudioContextResumed(); // Try resuming on first key press
        }

        if (canPlay) {
            pressedKeys[e.code] = true; // Mark key as held down
            const freq = midiToFreq(note);
            noteOn(note, freq); // Trigger note on
        } else if (isAudioInitialized) {
            console.warn("Audio Context not running. Please click the synth panel first.");
            // Optionally show a message to the user
        } else {
            console.error("Audio not initialized. Cannot play note.");
        }
    });

    // Global keyup listener
    document.addEventListener('keyup', (e) => {
        // --- Knob Control ---
        if (document.activeElement && document.activeElement.classList.contains('knob')) {
            // Stop repeating if the corresponding arrow key is released
            if ((e.key === 'ArrowLeft' && arrowKeyDown === 'left') || (e.key === 'ArrowRight' && arrowKeyDown === 'right')) {
                arrowKeyDown = null;
                stopArrowRepeat();
            }
        }
        // Update shift state and potentially restart repeat without shift multiplier
        if (e.key === 'Shift') {
            shiftKeyDown = false;
            // If an arrow key is still held down, restart repeat without shift multiplier
            if (arrowKeyDown && intervalId && document.activeElement && document.activeElement.classList.contains('knob')) {
                startArrowRepeat(document.activeElement, arrowKeyDown, false);
            }
        }

        // --- Note Playing ---
        const note = keyToNoteMap[e.code];
        if (note && pressedKeys[e.code]) { // If it's a mapped key that was held
            pressedKeys[e.code] = false; // Mark key as released
            noteOff(note); // Trigger note off
        }
    });

    // Handle window losing focus (blur)
    window.addEventListener('blur', () => {
        // Release any sounding note immediately to prevent stuck notes
        if (currentNote !== null && audioContext && audioContext.state === 'running') {
            const now = audioContext.currentTime;
            // Check if now is valid (context might be closed/suspended unexpectedly)
            if (now !== undefined && now > 0) {
                 // Instead of triggering release, just cut the sound instantly for safety on blur
                 if (vcaGainNode) {
                    vcaGainNode.gain.cancelScheduledValues(now);
                    vcaGainNode.gain.setValueAtTime(0.0001, now);
                 }
                 if (filter) {
                    filter.frequency.cancelScheduledValues(now);
                    // Reset filter frequency to its base knob value when note stops abruptly
                    filter.frequency.setValueAtTime(params.filter.frequency.value, now);
                 }
            }
            currentNote = null;
            currentFrequency = 0;
        }
        pressedKeys = {}; // Clear all held key states
        // Reset knob control state
        arrowKeyDown = null;
        stopArrowRepeat();
        if (isDragging) stopDrag(); // Stop mouse dragging if active
    });

    // -- Mouse Input for Knobs --
    let isDragging = false; // Flag if a knob is currently being dragged
    let dragKnob = null; // Reference to the knob being dragged
    let startY = 0; // Initial mouse Y position on drag start
    let startValue = 0; // Initial knob *percentage* (0-1) on drag start

    // Handles mouse movement during knob drag (MODIFIED for percentage)
    function handleKnobMouseMove(e) {
        if (!isDragging || !dragKnob) return;
        e.preventDefault();
        const currentY = e.clientY;
        const deltaY = startY - currentY; // Positive deltaY = dragging up

        const steps = dragKnob.dataset.steps ? dragKnob.dataset.steps.split(',') : null;
        const min = parseFloat(dragKnob.dataset.min); // Needed for log/linear calc
        const max = parseFloat(dragKnob.dataset.max); // Needed for log/linear calc
        const isLog = dragKnob.dataset.curve === 'log' && min > 0;

        // startValue now holds the starting *percentage* (set in mousedown listener)
        let startPercentage = startValue;

        if (steps) { // Stepped Knob Drag (based on percentage)
            const pixelsPerStep = 20; // Adjust sensitivity
            const totalSteps = steps.length;
            if (totalSteps <= 1) return; // Avoid division by zero

            // Calculate percentage change based on total knob travel for steps
            const totalDragPixelsForSteps = pixelsPerStep * (totalSteps - 1);
            const percentageChange = totalDragPixelsForSteps > 0 ? (deltaY / totalDragPixelsForSteps) : 0;

            let newPercentage = startPercentage + percentageChange;
            newPercentage = Math.max(0, Math.min(1, newPercentage));

            let newStepIndex = Math.round(newPercentage * (totalSteps - 1));

            // Read current index from data-value to compare
             let currentValueInDataStr = dragKnob.dataset.value;
             if (currentValueInDataStr === undefined || currentValueInDataStr === null) currentValueInDataStr = '0';
             let currentStepIndex = Math.round(parseFloat(currentValueInDataStr));

             if (newStepIndex !== currentStepIndex) {
                 updateParameter(dragKnob, newStepIndex);
             }

        } else { // Linear or Logarithmic Drag (based on percentage)
            const dragRangePixels = 150; // Pixels for full 0-1 range, adjust sensitivity
            const deltaPercentage = deltaY / dragRangePixels;
            let newPercentage = startPercentage + deltaPercentage;
            newPercentage = Math.max(0, Math.min(1, newPercentage)); // Clamp 0-1

            let newValue; // The new audio value
            if (isLog) {
                // Clamp percentage slightly away from 0 to avoid issues with Math.pow if min is very small
                const epsilon = 1e-9;
                const clampedPercentage = Math.max(epsilon, newPercentage);
                newValue = min * Math.pow(max / min, clampedPercentage);
            } else { // Linear
                 const range = max - min;
                 newValue = min + newPercentage * range;
            }
             newValue = Math.max(min, Math.min(max, newValue)); // Clamp audio value

            // Update parameter with the new audio value
            // updateParameter will handle clamping and storing this value
             updateParameter(dragKnob, newValue);
        }
    }


    // Stops the knob dragging operation
    function stopDrag() {
        if (isDragging) {
            isDragging = false;
            dragKnob = null;
            document.body.classList.remove('dragging'); // Remove dragging cursor from body
            // Remove temporary event listeners
            document.removeEventListener('mousemove', handleKnobMouseMove);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('mouseleave', stopDrag); // Also stop if mouse leaves window
        }
    }

    // Add event listeners to all knobs
    function setupKnobListeners() {
        if (!knobs) knobs = synthPanel.querySelectorAll('.knob');
        knobs.forEach(knob => {
            knob.addEventListener('mousedown', async (e) => { // Make async if using ensureAudioContextResumed
                // Ensure audio context is running or attempt to resume
                let canInteract = isAudioResumed;
                if (!canInteract && isAudioInitialized) {
                    canInteract = await ensureAudioContextResumed(); // Await resume attempt
                }
                // Optionally prevent interaction if context couldn't resume
                 if (!canInteract && isAudioInitialized) { // Only check if initialized but not resumed
                     console.warn("Audio Context not running, cannot interact.");
                     return;
                 }

                e.preventDefault();
                isDragging = true;
                dragKnob = knob;
                startY = e.clientY;

                // *** MODIFIED: Store the starting PERCENTAGE for drag ***
                startValue = getKnobPercentage(knob); // Use helper to get 0-1 value

                document.body.classList.add('dragging');
                document.addEventListener('mousemove', handleKnobMouseMove);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('mouseleave', stopDrag);
                knob.focus();
            });

            knob.addEventListener('dblclick', (e) => {
                // Reset knob to its initial default value on double click
                let defaultValueStr = knob.getAttribute('data-value') || '0';
                let defaultValue;
                 if (knob.dataset.steps) {
                     defaultValue = parseInt(defaultValueStr);
                 } else {
                     defaultValue = parseFloat(defaultValueStr);
                 }
                // Pass the default *value* or *index*
                updateParameter(knob, defaultValue);
            });
        });
    }


    // -- Switch Click/Key Listeners --
    function setupSwitchListeners() {
        if (!switches) switches = synthPanel.querySelectorAll('.switch');
        switches.forEach(sw => {
            const triggerSwitch = async () => { // Make async for ensureAudioContextResumed
                // Attempt to resume audio context on interaction
                let canInteract = isAudioResumed;
                if (!canInteract && isAudioInitialized) {
                    canInteract = await ensureAudioContextResumed();
                }
                 if (!canInteract && isAudioInitialized) { // Check again after attempting resume
                     console.warn("Audio Context not running, cannot interact.");
                     return;
                 }

                const currentState = sw.dataset.state;
                const newState = currentState === 'up' ? 'down' : 'up'; // Toggle state
                updateParameter(sw, newState);
            };
            sw.addEventListener('click', triggerSwitch); // Toggle on click
            sw.addEventListener('keydown', (e) => {
                // Allow toggling with Enter or Space when switch is focused
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault(); // Prevent default space bar scroll
                    triggerSwitch(); // Call the async trigger function
                }
            });
        });
    }

    // -- General Interaction Listener for Audio Context --
    // Ensures audio context can start on first click anywhere on the synth panel
    function setupGeneralInteractionListener() {
        // Use 'pointerdown' as it often fires earlier than 'click' and covers touch/pen
        synthPanel.addEventListener('pointerdown', () => {
            if (!isAudioResumed && isAudioInitialized) ensureAudioContextResumed();
        }, { capture: true, once: true }); // Use capture phase and only run once
    }

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        // Select knobs and switches after DOM is loaded
        knobs = synthPanel.querySelectorAll('.knob');
        switches = synthPanel.querySelectorAll('.switch');

        // Initialize audio graph and parameters first
        // initAudio now calls updateAllKnobs/Switches internally at the end
        initAudio();

        // Setup event listeners for UI elements AFTER initAudio has run
        // (initAudio ensures nodes exist before listeners try to use them)
        if (isAudioInitialized) {
            setupKnobListeners();
            setupSwitchListeners();
            setupGeneralInteractionListener();
        } else {
            console.error("Audio initialization failed, UI listeners not attached.");
        }


        console.log("Mono Synth Ready. Click panel or press keys (A, W, S, E, D, F, T, G, Y, H, U, J, K) to start audio and play.");
        if (isAudioInitialized && audioContext?.state === 'suspended') {
            console.warn("REMINDER: Click the synth panel or press a key to enable audio playback.");
            // Could display a visual indicator here as well
        }
    });

</script>
</body>
</html>